/*++

Copyright (C) 2019 Numbers developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Java file in order to allow an easy
 use of Numbers library

Interface version: 1.0.0

*/

package numbers;

import com.sun.jna.*;

import java.nio.charset.StandardCharsets;


public class NumbersWrapper {

	public static class EnumConversion {
	}

	protected Function numbers_createvariable;
	protected Function numbers_getversion;
	protected Function numbers_getlasterror;
	protected Function numbers_releaseinstance;
	protected Function numbers_acquireinstance;
	protected Function numbers_getsymbollookupmethod;
	protected Function numbers_base_classtypeid;
	protected Function numbers_variable_getvalue;
	protected Function numbers_variable_setvalue;

	protected NativeLibrary mLibrary;

	public NumbersWrapper(String libraryPath) {
		mLibrary = NativeLibrary.getInstance(libraryPath);
		numbers_createvariable = mLibrary.getFunction("numbers_createvariable");
		numbers_getversion = mLibrary.getFunction("numbers_getversion");
		numbers_getlasterror = mLibrary.getFunction("numbers_getlasterror");
		numbers_releaseinstance = mLibrary.getFunction("numbers_releaseinstance");
		numbers_acquireinstance = mLibrary.getFunction("numbers_acquireinstance");
		numbers_getsymbollookupmethod = mLibrary.getFunction("numbers_getsymbollookupmethod");
		numbers_base_classtypeid = mLibrary.getFunction("numbers_base_classtypeid");
		numbers_variable_getvalue = mLibrary.getFunction("numbers_variable_getvalue");
		numbers_variable_setvalue = mLibrary.getFunction("numbers_variable_setvalue");
	}

	public NumbersWrapper(Pointer lookupPointer) throws NumbersException {
		Function lookupMethod = Function.getFunction(lookupPointer);
		numbers_createvariable = loadFunctionByLookup(lookupMethod, "numbers_createvariable");
		numbers_getversion = loadFunctionByLookup(lookupMethod, "numbers_getversion");
		numbers_getlasterror = loadFunctionByLookup(lookupMethod, "numbers_getlasterror");
		numbers_releaseinstance = loadFunctionByLookup(lookupMethod, "numbers_releaseinstance");
		numbers_acquireinstance = loadFunctionByLookup(lookupMethod, "numbers_acquireinstance");
		numbers_getsymbollookupmethod = loadFunctionByLookup(lookupMethod, "numbers_getsymbollookupmethod");
		numbers_base_classtypeid = loadFunctionByLookup(lookupMethod, "numbers_base_classtypeid");
		numbers_variable_getvalue = loadFunctionByLookup(lookupMethod, "numbers_variable_getvalue");
		numbers_variable_setvalue = loadFunctionByLookup(lookupMethod, "numbers_variable_setvalue");
	}

	protected void checkError(Base instance, int errorCode) throws NumbersException {
		if (instance != null && instance.mWrapper != this) {
			throw new NumbersException(NumbersException.NUMBERS_ERROR_INVALIDCAST, "invalid wrapper call");
		}
		if (errorCode != NumbersException.NUMBERS_SUCCESS) {
			if (instance != null) {
				GetLastErrorResult result = getLastError(instance);
				throw new NumbersException(errorCode, result.ErrorMessage);
			} else {
				throw new NumbersException(errorCode, "");
			}
		}
	}

	private Function loadFunctionByLookup(Function lookupMethod, String functionName) throws NumbersException {
		byte[] bytes = functionName.getBytes(StandardCharsets.UTF_8);
		Memory name = new Memory(bytes.length+1);
		name.write(0, bytes, 0, bytes.length);
		name.setByte(bytes.length, (byte)0);
		Pointer address = new Memory(8);
		java.lang.Object[] addressParam = new java.lang.Object[]{name, address};
		checkError(null, lookupMethod.invokeInt(addressParam));
		return Function.getFunction(address.getPointer(0));
	}

	/**
	 * Creates a new Variable instance
	 *
	 * @param initialValue Initial value of the new Variable
	 * @return New Variable instance
	 * @throws NumbersException
	 */
	public Variable createVariable(double initialValue) throws NumbersException {
		Pointer bufferInstance = new Memory(8);
		checkError(null, numbers_createvariable.invokeInt(new java.lang.Object[]{initialValue, bufferInstance}));
		Pointer valueInstance = bufferInstance.getPointer(0);
		Variable instance = null;
		if (valueInstance == Pointer.NULL) {
		  throw new NumbersException(NumbersException.NUMBERS_ERROR_INVALIDPARAM, "Instance was a null pointer");
		}
		instance = this.PolymorphicFactory(valueInstance, Variable.class);
		return instance;
	}

	/**
	 * retrieves the binary version of this library.
	 *
	 * @return GetVersion Result Tuple
	 * @throws NumbersException
	 */
	public GetVersionResult getVersion() throws NumbersException {
		Pointer bufferMajor = new Memory(4);
		Pointer bufferMinor = new Memory(4);
		Pointer bufferMicro = new Memory(4);
		checkError(null, numbers_getversion.invokeInt(new java.lang.Object[]{bufferMajor, bufferMinor, bufferMicro}));
		GetVersionResult returnTuple = new GetVersionResult();
		returnTuple.Major = bufferMajor.getInt(0);
		returnTuple.Minor = bufferMinor.getInt(0);
		returnTuple.Micro = bufferMicro.getInt(0);
		return returnTuple;
	}

	public static class GetVersionResult {
		/**
		 * returns the major version of this library
		 */
		public int Major;

		/**
		 * returns the minor version of this library
		 */
		public int Minor;

		/**
		 * returns the micro version of this library
		 */
		public int Micro;

	}
	/**
	 * Returns the last error recorded on this object
	 *
	 * @param instance Instance Handle
	 * @return GetLastError Result Tuple
	 * @throws NumbersException
	 */
	public GetLastErrorResult getLastError(Base instance) throws NumbersException {
		Pointer instanceHandle = null;
		if (instance != null) {
			instanceHandle = instance.getHandle();
		} else {
			throw new NumbersException(NumbersException.NUMBERS_ERROR_INVALIDPARAM, "Instance is a null value.");
		}
		Pointer bytesNeededErrorMessage = new Memory(4);
		Pointer bufferHasError = new Memory(1);
		checkError(null, numbers_getlasterror.invokeInt(new java.lang.Object[]{instanceHandle, 0, bytesNeededErrorMessage, null, bufferHasError}));
		int sizeErrorMessage = bytesNeededErrorMessage.getInt(0);
		Pointer bufferErrorMessage = new Memory(sizeErrorMessage);
		checkError(null, numbers_getlasterror.invokeInt(new java.lang.Object[]{instanceHandle, sizeErrorMessage, bytesNeededErrorMessage, bufferErrorMessage, bufferHasError}));
		GetLastErrorResult returnTuple = new GetLastErrorResult();
		returnTuple.ErrorMessage = new String(bufferErrorMessage.getByteArray(0, sizeErrorMessage - 1), StandardCharsets.UTF_8);
		returnTuple.HasError = bufferHasError.getByte(0) != 0;
		return returnTuple;
	}

	public static class GetLastErrorResult {
		/**
		 * Message of the last error
		 */
		public String ErrorMessage;

		/**
		 * Is there a last error to query
		 */
		public boolean HasError;

	}
	/**
	 * Releases shared ownership of an Instance
	 *
	 * @param instance Instance Handle
	 * @throws NumbersException
	 */
	public void releaseInstance(Base instance) throws NumbersException {
		Pointer instanceHandle = null;
		if (instance != null) {
			instanceHandle = instance.getHandle();
		} else {
			throw new NumbersException(NumbersException.NUMBERS_ERROR_INVALIDPARAM, "Instance is a null value.");
		}
		checkError(null, numbers_releaseinstance.invokeInt(new java.lang.Object[]{instanceHandle}));
	}

	/**
	 * Acquires shared ownership of an Instance
	 *
	 * @param instance Instance Handle
	 * @throws NumbersException
	 */
	public void acquireInstance(Base instance) throws NumbersException {
		Pointer instanceHandle = null;
		if (instance != null) {
			instanceHandle = instance.getHandle();
		} else {
			throw new NumbersException(NumbersException.NUMBERS_ERROR_INVALIDPARAM, "Instance is a null value.");
		}
		checkError(null, numbers_acquireinstance.invokeInt(new java.lang.Object[]{instanceHandle}));
	}

	/**
	 * Returns the address of the SymbolLookupMethod
	 *
	 * @return Address of the SymbolAddressMethod
	 * @throws NumbersException
	 */
	public Pointer getSymbolLookupMethod() throws NumbersException {
		Pointer bufferSymbolLookupMethod = new Memory(8);
		checkError(null, numbers_getsymbollookupmethod.invokeInt(new java.lang.Object[]{bufferSymbolLookupMethod}));
		return bufferSymbolLookupMethod.getPointer(0);
	}

	/**
	 * IMPORTANT: PolymorphicFactory method should not be used by application directly.
	 *            It's designed to be used on NumbersHandle object only once.
	 *            If it's used on any existing object as a form of dynamic cast then
	 *            NumbersWrapper::acquireInstance(Base object) must be called after instantiating new object.
	 *            This is important to keep reference count matching between application and library sides.
	*/
	public <T> T PolymorphicFactory(Pointer handle, Class<T> cls) {
		if (handle == Pointer.NULL)
		 return null;
		 Class[] cArg = new Class[2];
		 cArg[0] = NumbersWrapper.class;
		 cArg[1] = Pointer.class;
			
			try {
		   T obj = null;
		   Pointer bufferClassTypeId = new Memory(8);
		   checkError(null, numbers_base_classtypeid.invokeInt(new java.lang.Object[]{handle, bufferClassTypeId}));
		   long classTypeId = bufferClassTypeId.getLong(0);
		   
		   int msbId = (int)(classTypeId >> 32); 
		   int lsbId = (int)classTypeId; 
			switch(msbId) {
				case 0x23934EDF: 
					switch(lsbId) {
						case 0x762423EA: obj = (T)(new Variable(this, handle)); break; // First 64 bits of SHA1 of a string: "Numbers::Variable"
					}
				break;
				case 0x27799F69: 
					switch(lsbId) {
						case 0xB3FD1C9E: obj = (T)(new Base(this, handle)); break; // First 64 bits of SHA1 of a string: "Numbers::Base"
					}
				break;
				default: obj = cls.getDeclaredConstructor(cArg).newInstance(this, handle); break;
			}
			return obj;
		}
		catch(Exception e) {
			return null;
		}
	}
}

