/*++

Copyright (C) 2019 Numbers developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Numbers library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "numbers_abi.hpp"
#include "numbers_interfaces.hpp"
#include "numbers_interfaceexception.hpp"

#include <map>

using namespace Numbers::Impl;

NumbersResult handleNumbersException(IBase * pIBaseClass, ENumbersInterfaceException & Exception)
{
	NumbersResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

NumbersResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	NumbersResult errorCode = NUMBERS_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

NumbersResult handleUnhandledException(IBase * pIBaseClass)
{
	NumbersResult errorCode = NUMBERS_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/
NumbersResult numbers_base_classtypeid(Numbers_Base pBase, Numbers_uint64 * pClassTypeId)
{
	IBase* pIBaseClass = (IBase *)pBase.Handle;

	try {
		if (pClassTypeId == nullptr)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		IBase* pIBase = dynamic_cast<IBase*>(pIBaseClass);
		if (!pIBase)
			throw ENumbersInterfaceException(NUMBERS_ERROR_INVALIDCAST);
		
		*pClassTypeId = pIBase->ClassTypeId();

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Variable
**************************************************************************************************************************/
NumbersResult numbers_variable_getvalue(Numbers_Variable pVariable, Numbers_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pVariable.Handle;

	try {
		if (pValue == nullptr)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		IVariable* pIVariable = dynamic_cast<IVariable*>(pIBaseClass);
		if (!pIVariable)
			throw ENumbersInterfaceException(NUMBERS_ERROR_INVALIDCAST);
		
		*pValue = pIVariable->GetValue();

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

NumbersResult numbers_variable_setvalue(Numbers_Variable pVariable, Numbers_double dValue)
{
	IBase* pIBaseClass = (IBase *)pVariable.Handle;

	try {
		IVariable* pIVariable = dynamic_cast<IVariable*>(pIBaseClass);
		if (!pIVariable)
			throw ENumbersInterfaceException(NUMBERS_ERROR_INVALIDCAST);
		
		pIVariable->SetValue(dValue);

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

NumbersResult Numbers::Impl::Numbers_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return NUMBERS_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return NUMBERS_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "numbers_base_classtypeid") 
		*ppProcAddress = (void*) &numbers_base_classtypeid;
	if (sProcName == "numbers_variable_getvalue") 
		*ppProcAddress = (void*) &numbers_variable_getvalue;
	if (sProcName == "numbers_variable_setvalue") 
		*ppProcAddress = (void*) &numbers_variable_setvalue;
	if (sProcName == "numbers_createvariable") 
		*ppProcAddress = (void*) &numbers_createvariable;
	if (sProcName == "numbers_getversion") 
		*ppProcAddress = (void*) &numbers_getversion;
	if (sProcName == "numbers_getlasterror") 
		*ppProcAddress = (void*) &numbers_getlasterror;
	if (sProcName == "numbers_releaseinstance") 
		*ppProcAddress = (void*) &numbers_releaseinstance;
	if (sProcName == "numbers_acquireinstance") 
		*ppProcAddress = (void*) &numbers_acquireinstance;
	if (sProcName == "numbers_getsymbollookupmethod") 
		*ppProcAddress = (void*) &numbers_getsymbollookupmethod;
	
	if (*ppProcAddress == nullptr) 
		return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return NUMBERS_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
NumbersResult numbers_createvariable(Numbers_double dInitialValue, Numbers_Variable * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateVariable(dInitialValue);

		pInstance->Handle = (IBase*)(pBaseInstance);
		pInstance->ClassTypeId = pBaseInstance == nullptr ? 0 : pBaseInstance->ClassTypeId();
		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

NumbersResult numbers_getversion(Numbers_uint32 * pMajor, Numbers_uint32 * pMinor, Numbers_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

NumbersResult numbers_getlasterror(Numbers_Base pInstance, const Numbers_uint32 nErrorMessageBufferSize, Numbers_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance.Handle;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (Numbers_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ENumbersInterfaceException (NUMBERS_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

NumbersResult numbers_releaseinstance(Numbers_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance.Handle;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

NumbersResult numbers_acquireinstance(Numbers_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance.Handle;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

NumbersResult numbers_getsymbollookupmethod(Numbers_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ENumbersInterfaceException (NUMBERS_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&Numbers::Impl::Numbers_GetProcAddress;
		return NUMBERS_SUCCESS;
	}
	catch (ENumbersInterfaceException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


