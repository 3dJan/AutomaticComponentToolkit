/*++

Copyright (C) 2019 Calculation developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Java file in order to allow an easy
 use of Calculation library

Interface version: 1.0.0

*/

package calculation;

import com.sun.jna.*;

import java.nio.charset.StandardCharsets;

import numbers.*;

public class CalculationWrapper {

	public static class EnumConversion {
	}

	protected Function calculation_createcalculator;
	protected Function calculation_getversion;
	protected Function calculation_getlasterror;
	protected Function calculation_releaseinstance;
	protected Function calculation_acquireinstance;
	protected Function calculation_injectcomponent;
	protected Function calculation_getsymbollookupmethod;
	protected Function calculation_base_classtypeid;
	protected Function calculation_calculator_enlistvariable;
	protected Function calculation_calculator_getenlistedvariable;
	protected Function calculation_calculator_clearvariables;
	protected Function calculation_calculator_multiply;
	protected Function calculation_calculator_add;

	protected NativeLibrary mLibrary;

	protected NumbersWrapper mNumbersWrapper;

	public CalculationWrapper(String libraryPath) {
		mLibrary = NativeLibrary.getInstance(libraryPath);
		calculation_createcalculator = mLibrary.getFunction("calculation_createcalculator");
		calculation_getversion = mLibrary.getFunction("calculation_getversion");
		calculation_getlasterror = mLibrary.getFunction("calculation_getlasterror");
		calculation_releaseinstance = mLibrary.getFunction("calculation_releaseinstance");
		calculation_acquireinstance = mLibrary.getFunction("calculation_acquireinstance");
		calculation_injectcomponent = mLibrary.getFunction("calculation_injectcomponent");
		calculation_getsymbollookupmethod = mLibrary.getFunction("calculation_getsymbollookupmethod");
		calculation_base_classtypeid = mLibrary.getFunction("calculation_base_classtypeid");
		calculation_calculator_enlistvariable = mLibrary.getFunction("calculation_calculator_enlistvariable");
		calculation_calculator_getenlistedvariable = mLibrary.getFunction("calculation_calculator_getenlistedvariable");
		calculation_calculator_clearvariables = mLibrary.getFunction("calculation_calculator_clearvariables");
		calculation_calculator_multiply = mLibrary.getFunction("calculation_calculator_multiply");
		calculation_calculator_add = mLibrary.getFunction("calculation_calculator_add");
	}

	public CalculationWrapper(Pointer lookupPointer) throws CalculationException {
		Function lookupMethod = Function.getFunction(lookupPointer);
		calculation_createcalculator = loadFunctionByLookup(lookupMethod, "calculation_createcalculator");
		calculation_getversion = loadFunctionByLookup(lookupMethod, "calculation_getversion");
		calculation_getlasterror = loadFunctionByLookup(lookupMethod, "calculation_getlasterror");
		calculation_releaseinstance = loadFunctionByLookup(lookupMethod, "calculation_releaseinstance");
		calculation_acquireinstance = loadFunctionByLookup(lookupMethod, "calculation_acquireinstance");
		calculation_injectcomponent = loadFunctionByLookup(lookupMethod, "calculation_injectcomponent");
		calculation_getsymbollookupmethod = loadFunctionByLookup(lookupMethod, "calculation_getsymbollookupmethod");
		calculation_base_classtypeid = loadFunctionByLookup(lookupMethod, "calculation_base_classtypeid");
		calculation_calculator_enlistvariable = loadFunctionByLookup(lookupMethod, "calculation_calculator_enlistvariable");
		calculation_calculator_getenlistedvariable = loadFunctionByLookup(lookupMethod, "calculation_calculator_getenlistedvariable");
		calculation_calculator_clearvariables = loadFunctionByLookup(lookupMethod, "calculation_calculator_clearvariables");
		calculation_calculator_multiply = loadFunctionByLookup(lookupMethod, "calculation_calculator_multiply");
		calculation_calculator_add = loadFunctionByLookup(lookupMethod, "calculation_calculator_add");
	}

	protected void checkError(Base instance, int errorCode) throws CalculationException {
		if (instance != null && instance.mWrapper != this) {
			throw new CalculationException(CalculationException.CALCULATION_ERROR_INVALIDCAST, "invalid wrapper call");
		}
		if (errorCode != CalculationException.CALCULATION_SUCCESS) {
			if (instance != null) {
				GetLastErrorResult result = getLastError(instance);
				throw new CalculationException(errorCode, result.ErrorMessage);
			} else {
				throw new CalculationException(errorCode, "");
			}
		}
	}

	private Function loadFunctionByLookup(Function lookupMethod, String functionName) throws CalculationException {
		byte[] bytes = functionName.getBytes(StandardCharsets.UTF_8);
		Memory name = new Memory(bytes.length+1);
		name.write(0, bytes, 0, bytes.length);
		name.setByte(bytes.length, (byte)0);
		Pointer address = new Memory(8);
		java.lang.Object[] addressParam = new java.lang.Object[]{name, address};
		checkError(null, lookupMethod.invokeInt(addressParam));
		return Function.getFunction(address.getPointer(0));
	}

	public NumbersWrapper getNumbersWrapper() {
		return mNumbersWrapper;
	}

	/**
	 * Creates a new Calculator instance
	 *
	 * @return New Calculator instance
	 * @throws CalculationException
	 */
	public Calculator createCalculator() throws CalculationException {
		Pointer bufferInstance = new Memory(8);
		checkError(null, calculation_createcalculator.invokeInt(new java.lang.Object[]{bufferInstance}));
		Pointer valueInstance = bufferInstance.getPointer(0);
		Calculator instance = null;
		if (valueInstance == Pointer.NULL) {
		  throw new CalculationException(CalculationException.CALCULATION_ERROR_INVALIDPARAM, "Instance was a null pointer");
		}
		instance = this.PolymorphicFactory(valueInstance, Calculator.class);
		return instance;
	}

	/**
	 * retrieves the binary version of this library.
	 *
	 * @return GetVersion Result Tuple
	 * @throws CalculationException
	 */
	public GetVersionResult getVersion() throws CalculationException {
		Pointer bufferMajor = new Memory(4);
		Pointer bufferMinor = new Memory(4);
		Pointer bufferMicro = new Memory(4);
		checkError(null, calculation_getversion.invokeInt(new java.lang.Object[]{bufferMajor, bufferMinor, bufferMicro}));
		GetVersionResult returnTuple = new GetVersionResult();
		returnTuple.Major = bufferMajor.getInt(0);
		returnTuple.Minor = bufferMinor.getInt(0);
		returnTuple.Micro = bufferMicro.getInt(0);
		return returnTuple;
	}

	public static class GetVersionResult {
		/**
		 * returns the major version of this library
		 */
		public int Major;

		/**
		 * returns the minor version of this library
		 */
		public int Minor;

		/**
		 * returns the micro version of this library
		 */
		public int Micro;

	}
	/**
	 * Returns the last error recorded on this object
	 *
	 * @param instance Instance Handle
	 * @return GetLastError Result Tuple
	 * @throws CalculationException
	 */
	public GetLastErrorResult getLastError(Base instance) throws CalculationException {
		Pointer instanceHandle = null;
		if (instance != null) {
			instanceHandle = instance.getHandle();
		} else {
			throw new CalculationException(CalculationException.CALCULATION_ERROR_INVALIDPARAM, "Instance is a null value.");
		}
		Pointer bytesNeededErrorMessage = new Memory(4);
		Pointer bufferHasError = new Memory(1);
		checkError(null, calculation_getlasterror.invokeInt(new java.lang.Object[]{instanceHandle, 0, bytesNeededErrorMessage, null, bufferHasError}));
		int sizeErrorMessage = bytesNeededErrorMessage.getInt(0);
		Pointer bufferErrorMessage = new Memory(sizeErrorMessage);
		checkError(null, calculation_getlasterror.invokeInt(new java.lang.Object[]{instanceHandle, sizeErrorMessage, bytesNeededErrorMessage, bufferErrorMessage, bufferHasError}));
		GetLastErrorResult returnTuple = new GetLastErrorResult();
		returnTuple.ErrorMessage = new String(bufferErrorMessage.getByteArray(0, sizeErrorMessage - 1), StandardCharsets.UTF_8);
		returnTuple.HasError = bufferHasError.getByte(0) != 0;
		return returnTuple;
	}

	public static class GetLastErrorResult {
		/**
		 * Message of the last error
		 */
		public String ErrorMessage;

		/**
		 * Is there a last error to query
		 */
		public boolean HasError;

	}
	/**
	 * Releases shared ownership of an Instance
	 *
	 * @param instance Instance Handle
	 * @throws CalculationException
	 */
	public void releaseInstance(Base instance) throws CalculationException {
		Pointer instanceHandle = null;
		if (instance != null) {
			instanceHandle = instance.getHandle();
		} else {
			throw new CalculationException(CalculationException.CALCULATION_ERROR_INVALIDPARAM, "Instance is a null value.");
		}
		checkError(null, calculation_releaseinstance.invokeInt(new java.lang.Object[]{instanceHandle}));
	}

	/**
	 * Acquires shared ownership of an Instance
	 *
	 * @param instance Instance Handle
	 * @throws CalculationException
	 */
	public void acquireInstance(Base instance) throws CalculationException {
		Pointer instanceHandle = null;
		if (instance != null) {
			instanceHandle = instance.getHandle();
		} else {
			throw new CalculationException(CalculationException.CALCULATION_ERROR_INVALIDPARAM, "Instance is a null value.");
		}
		checkError(null, calculation_acquireinstance.invokeInt(new java.lang.Object[]{instanceHandle}));
	}

	/**
	 * Injects an imported component for usage within this component
	 *
	 * @param nameSpace NameSpace of the injected component
	 * @param symbolAddressMethod Address of the SymbolAddressMethod of the injected component
	 * @throws CalculationException
	 */
	public void injectComponent(String nameSpace, Pointer symbolAddressMethod) throws CalculationException, NumbersException {
		byte[] bytesNameSpace = nameSpace.getBytes(StandardCharsets.UTF_8);
		Memory bufferNameSpace = new Memory(bytesNameSpace.length + 1);
		bufferNameSpace.write(0, bytesNameSpace, 0, bytesNameSpace.length);
		bufferNameSpace.setByte(bytesNameSpace.length, (byte)0);
		checkError(null, calculation_injectcomponent.invokeInt(new java.lang.Object[]{bufferNameSpace, symbolAddressMethod}));

		boolean nameSpaceFound = false;
		if ("Numbers".equals(nameSpace)) {
			if (mNumbersWrapper != null) {
				throw new CalculationException(CalculationException.CALCULATION_ERROR_COULDNOTLOADLIBRARY, "Library with namespace ' + nameSpace + ' is already registered.");
			}
			mNumbersWrapper = new NumbersWrapper(symbolAddressMethod);
			nameSpaceFound = true;
		}
		if (!nameSpaceFound) {
			throw new CalculationException(CalculationException.CALCULATION_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + nameSpace);
		}
	}

	/**
	 * Returns the address of the SymbolLookupMethod
	 *
	 * @return Address of the SymbolAddressMethod
	 * @throws CalculationException
	 */
	public Pointer getSymbolLookupMethod() throws CalculationException {
		Pointer bufferSymbolLookupMethod = new Memory(8);
		checkError(null, calculation_getsymbollookupmethod.invokeInt(new java.lang.Object[]{bufferSymbolLookupMethod}));
		return bufferSymbolLookupMethod.getPointer(0);
	}

	/**
	 * IMPORTANT: PolymorphicFactory method should not be used by application directly.
	 *            It's designed to be used on CalculationHandle object only once.
	 *            If it's used on any existing object as a form of dynamic cast then
	 *            CalculationWrapper::acquireInstance(Base object) must be called after instantiating new object.
	 *            This is important to keep reference count matching between application and library sides.
	*/
	public <T> T PolymorphicFactory(Pointer handle, Class<T> cls) {
		if (handle == Pointer.NULL)
		 return null;
		 Class[] cArg = new Class[2];
		 cArg[0] = CalculationWrapper.class;
		 cArg[1] = Pointer.class;
			
			try {
		   T obj = null;
		   Pointer bufferClassTypeId = new Memory(8);
		   checkError(null, calculation_base_classtypeid.invokeInt(new java.lang.Object[]{handle, bufferClassTypeId}));
		   long classTypeId = bufferClassTypeId.getLong(0);
		   
		   int msbId = (int)(classTypeId >> 32); 
		   int lsbId = (int)classTypeId; 
			switch(msbId) {
				case 0x3BA5271B: 
					switch(lsbId) {
						case 0xAB410E5D: obj = (T)(new Base(this, handle)); break; // First 64 bits of SHA1 of a string: "Calculation::Base"
					}
				break;
				case 0xB23F5143: 
					switch(lsbId) {
						case 0x53D0C606: obj = (T)(new Calculator(this, handle)); break; // First 64 bits of SHA1 of a string: "Calculation::Calculator"
					}
				break;
				default: obj = cls.getDeclaredConstructor(cArg).newInstance(this, handle); break;
			}
			return obj;
		}
		catch(Exception e) {
			return null;
		}
	}
}

