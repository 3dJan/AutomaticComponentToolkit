/*++

Copyright (C) 2019 Special Numbers developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Special Numbers library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "special_abi.hpp"
#include "special_interfaces.hpp"
#include "special_interfaceexception.hpp"

#include <map>

using namespace Special::Impl;


SpecialResult handleSpecialException(IBase * pIBaseClass, ESpecialInterfaceException & Exception)
{
	SpecialResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

SpecialResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	SpecialResult errorCode = SPECIAL_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

SpecialResult handleUnhandledException(IBase * pIBaseClass)
{
	SpecialResult errorCode = SPECIAL_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/
SpecialResult special_base_getsymbollookupmethod(Special_Base pBase, Special_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = (IBase *)pBase.m_hHandle;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		IBase* pIBase = dynamic_cast<IBase*>(pIBaseClass);
		if (!pIBase)
			throw ESpecialInterfaceException(SPECIAL_ERROR_INVALIDCAST);
		
		*pSymbolLookupMethod = pIBase->GetSymbolLookupMethod();

		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_base_releaseinstance(Special_Base pBase)
{
	IBase* pIBaseClass = (IBase *)pBase.m_hHandle;

	try {
		IBase* pIBase = dynamic_cast<IBase*>(pIBaseClass);
		if (!pIBase)
			throw ESpecialInterfaceException(SPECIAL_ERROR_INVALIDCAST);
		
		pIBase->ReleaseInstance();

		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_base_acquireinstance(Special_Base pBase)
{
	IBase* pIBaseClass = (IBase *)pBase.m_hHandle;

	try {
		IBase* pIBase = dynamic_cast<IBase*>(pIBaseClass);
		if (!pIBase)
			throw ESpecialInterfaceException(SPECIAL_ERROR_INVALIDCAST);
		
		pIBase->AcquireInstance();

		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_base_getversion(Special_Base pBase, Special_uint32 * pMajor, Special_uint32 * pMinor, Special_uint32 * pMicro)
{
	IBase* pIBaseClass = (IBase *)pBase.m_hHandle;

	try {
		if (!pMajor)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		IBase* pIBase = dynamic_cast<IBase*>(pIBaseClass);
		if (!pIBase)
			throw ESpecialInterfaceException(SPECIAL_ERROR_INVALIDCAST);
		
		pIBase->GetVersion(*pMajor, *pMinor, *pMicro);

		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_base_getlasterror(Special_Base pBase, const Special_uint32 nErrorMessageBufferSize, Special_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = (IBase *)pBase.m_hHandle;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		std::string sErrorMessage("");
		IBase* pIBase = dynamic_cast<IBase*>(pIBaseClass);
		if (!pIBase)
			throw ESpecialInterfaceException(SPECIAL_ERROR_INVALIDCAST);
		
		*pHasError = pIBase->GetLastError(sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (Special_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ESpecialInterfaceException (SPECIAL_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SpecialVariable
**************************************************************************************************************************/
SpecialResult special_specialvariable_getspecialvalue(Special_SpecialVariable pSpecialVariable, Special_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pSpecialVariable.m_hHandle;

	try {
		if (pValue == nullptr)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		ISpecialVariable* pISpecialVariable = dynamic_cast<ISpecialVariable*>(pIBaseClass);
		if (!pISpecialVariable)
			throw ESpecialInterfaceException(SPECIAL_ERROR_INVALIDCAST);
		
		*pValue = pISpecialVariable->GetSpecialValue();

		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Variable
**************************************************************************************************************************/
SpecialResult special_specialvariable_getvalue(Special_SpecialVariable pSpecialVariable, Special_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pSpecialVariable.m_hHandle;

	try {
		if (pValue == nullptr)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		ISpecialVariable* pISpecialVariable = dynamic_cast<ISpecialVariable*>(pIBaseClass);
		if (!pISpecialVariable)
			throw ESpecialInterfaceException(SPECIAL_ERROR_INVALIDCAST);
		
		*pValue = pISpecialVariable->GetValue();

		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_specialvariable_setvalue(Special_SpecialVariable pSpecialVariable, Special_double dValue)
{
	IBase* pIBaseClass = (IBase *)pSpecialVariable.m_hHandle;

	try {
		ISpecialVariable* pISpecialVariable = dynamic_cast<ISpecialVariable*>(pIBaseClass);
		if (!pISpecialVariable)
			throw ESpecialInterfaceException(SPECIAL_ERROR_INVALIDCAST);
		
		pISpecialVariable->SetValue(dValue);

		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

SpecialResult _special_getprocaddress_internal(const char * pProcName, void ** ppProcAddress)
{
	static bool sbProcAddressMapHasBeenInitialized = false;
	static std::map<std::string, void*> sProcAddressMap;
	if (!sbProcAddressMapHasBeenInitialized) {
		sProcAddressMap["special_base_getsymbollookupmethod"] = (void*)&special_base_getsymbollookupmethod;
		sProcAddressMap["special_base_releaseinstance"] = (void*)&special_base_releaseinstance;
		sProcAddressMap["special_base_acquireinstance"] = (void*)&special_base_acquireinstance;
		sProcAddressMap["special_base_getversion"] = (void*)&special_base_getversion;
		sProcAddressMap["special_base_getlasterror"] = (void*)&special_base_getlasterror;
		sProcAddressMap["special_specialvariable_getspecialvalue"] = (void*)&special_specialvariable_getspecialvalue;
		sProcAddressMap["special_createspecialvariableasvariable"] = (void*)&special_createspecialvariableasvariable;
		sProcAddressMap["special_createspecialvariable"] = (void*)&special_createspecialvariable;
		sProcAddressMap["special_getsymbollookupmethod"] = (void*)&special_getsymbollookupmethod;
		sProcAddressMap["special_getlasterror"] = (void*)&special_getlasterror;
		sProcAddressMap["special_getversion"] = (void*)&special_getversion;
		
		sbProcAddressMapHasBeenInitialized = true;
	}
	if (pProcName == nullptr)
		return SPECIAL_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return SPECIAL_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	auto procPair = sProcAddressMap.find(sProcName);
	if (procPair == sProcAddressMap.end()) {
		return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
	}
	else {
		*ppProcAddress = procPair->second;
		return SPECIAL_SUCCESS;
	}
	
}

/*************************************************************************************************************************
 Function table lookup implementation for class Base
**************************************************************************************************************************/

SpecialResult _special_getprocaddress_base(const char * pProcName, void ** ppProcAddress)
{
	static bool sbProcAddressMapHasBeenInitialized = false;
	static std::map<std::string, void*> sProcAddressMap;
	if (!sbProcAddressMapHasBeenInitialized) {
		sProcAddressMap["special_base_getsymbollookupmethod"] = (void*)&special_base_getsymbollookupmethod;
		sProcAddressMap["special_base_releaseinstance"] = (void*)&special_base_releaseinstance;
		sProcAddressMap["special_base_acquireinstance"] = (void*)&special_base_acquireinstance;
		sProcAddressMap["special_base_getversion"] = (void*)&special_base_getversion;
		sProcAddressMap["special_base_getlasterror"] = (void*)&special_base_getlasterror;
		
		sbProcAddressMapHasBeenInitialized = true;
	}
	if (pProcName == nullptr)
		return SPECIAL_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return SPECIAL_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	auto procPair = sProcAddressMap.find(sProcName);
	if (procPair == sProcAddressMap.end()) {
		return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
	}
	else {
		*ppProcAddress = procPair->second;
		return SPECIAL_SUCCESS;
	}
	
}

/*************************************************************************************************************************
 Function table lookup implementation for class SpecialVariable
**************************************************************************************************************************/

SpecialResult _special_getprocaddress_specialvariable(const char * pProcName, void ** ppProcAddress)
{
	static bool sbProcAddressMapHasBeenInitialized = false;
	static std::map<std::string, void*> sProcAddressMap;
	if (!sbProcAddressMapHasBeenInitialized) {
		sProcAddressMap["numbers_base_getsymbollookupmethod"] = (void*)&special_base_getsymbollookupmethod;
		sProcAddressMap["numbers_base_releaseinstance"] = (void*)&special_base_releaseinstance;
		sProcAddressMap["numbers_base_acquireinstance"] = (void*)&special_base_acquireinstance;
		sProcAddressMap["numbers_base_getversion"] = (void*)&special_base_getversion;
		sProcAddressMap["numbers_base_getlasterror"] = (void*)&special_base_getlasterror;
		sProcAddressMap["numbers_variable_getvalue"] = (void*)&special_specialvariable_getvalue;
		sProcAddressMap["numbers_specialvariable_getvalue"] = (void*)&special_specialvariable_getvalue;
		sProcAddressMap["numbers_variable_setvalue"] = (void*)&special_specialvariable_setvalue;
		sProcAddressMap["numbers_specialvariable_setvalue"] = (void*)&special_specialvariable_setvalue;
		sProcAddressMap["special_specialvariable_getspecialvalue"] = (void*)&special_specialvariable_getspecialvalue;
		
		sbProcAddressMapHasBeenInitialized = true;
	}
	if (pProcName == nullptr)
		return SPECIAL_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return SPECIAL_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	auto procPair = sProcAddressMap.find(sProcName);
	if (procPair == sProcAddressMap.end()) {
		return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
	}
	else {
		*ppProcAddress = procPair->second;
		return SPECIAL_SUCCESS;
	}
	
}



/*************************************************************************************************************************
 Initialize lookup function pointers
**************************************************************************************************************************/
SpecialSymbolLookupType IBase::s_SymbolLookupMethodBase = &_special_getprocaddress_base;
SpecialSymbolLookupType ISpecialVariable::s_SymbolLookupMethodSpecialVariable = &_special_getprocaddress_specialvariable;



/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
SpecialResult special_createspecialvariableasvariable(Special_double dInitialValue, Numbers_Variable * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		Numbers::Binding::PVariable pNumbersInstance;
		pNumbersInstance = CWrapper::CreateSpecialVariableAsVariable(dInitialValue);

		// TODO: this does not work necessarily@ pBaseInstance might be nullptr
		pNumbersInstance->AcquireInstance();
		*pInstance = pNumbersInstance->GetHandle();
		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_createspecialvariable(Special_double dInitialValue, Special_SpecialVariable * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateSpecialVariable(dInitialValue);

		// TODO: this does not work necessarily@ pBaseInstance might be nullptr
		*pInstance = pBaseInstance->GetExtendedHandle();
		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_getsymbollookupmethod(Special_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = &_special_getprocaddress_internal;
		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_getlasterror(const Special_uint32 nErrorMessageBufferSize, Special_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (Special_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ESpecialInterfaceException (SPECIAL_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

SpecialResult special_getversion(Special_uint32 * pMajor, Special_uint32 * pMinor, Special_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ESpecialInterfaceException (SPECIAL_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return SPECIAL_SUCCESS;
	}
	catch (ESpecialInterfaceException & Exception) {
		return handleSpecialException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


