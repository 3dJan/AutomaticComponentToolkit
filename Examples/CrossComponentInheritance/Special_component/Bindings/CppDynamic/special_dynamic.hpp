/*++

Copyright (C) 2019 Special Numbers developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Special Numbers library

Interface version: 1.0.0

*/

#ifndef __SPECIAL_CPPHEADER_DYNAMIC_CPP
#define __SPECIAL_CPPHEADER_DYNAMIC_CPP

#include "special_types.hpp"
#include "special_dynamic.h"

#include "numbers_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>
#include <map>

namespace Special {
namespace Binding {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CSpecialVariable;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CSpecialWrapper;
typedef CBase CSpecialBase;
typedef CSpecialVariable CSpecialSpecialVariable;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CSpecialVariable> PSpecialVariable;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PSpecialWrapper;
typedef PBase PSpecialBase;
typedef PSpecialVariable PSpecialSpecialVariable;


/*************************************************************************************************************************
 Class ESpecialException 
**************************************************************************************************************************/
class ESpecialException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	SpecialResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ESpecialException(SpecialResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("Special Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	/**
	* Returns error code
	*/
	SpecialResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CSpecialInputVector = CInputVector<T>;


/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(initWrapperTable(&m_WrapperTable));
		CheckError(loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(checkBinaryVersion());
	}
	
	CWrapper(const std::string &sFileName)
	{
		CheckError(initWrapperTable(&m_WrapperTable));
		CheckError(loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(SpecialResult nResult);

	inline Numbers::Binding::PVariable CreateSpecialVariableAsVariable(const Special_double dInitialValue);
	inline PSpecialVariable CreateSpecialVariable(const Special_double dInitialValue);
	inline Special_pvoid GetSymbolLookupMethod();
	inline bool GetLastError(std::string & sErrorMessage);
	inline void GetVersion(Special_uint32 & nMajor, Special_uint32 & nMinor, Special_uint32 & nMicro);

private:
	sSpecialDynamicWrapperTable m_WrapperTable;
	// Injected Components
	Numbers::Binding::PWrapper m_pNumbersWrapper;

	
	SpecialResult checkBinaryVersion()
	{
		Special_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != SPECIAL_VERSION_MAJOR) || (nMinor < SPECIAL_VERSION_MINOR) ) {
			return SPECIAL_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return SPECIAL_SUCCESS;
	}
	SpecialResult initWrapperTable(sSpecialDynamicWrapperTable * pWrapperTable);
	SpecialResult releaseWrapperTable(sSpecialDynamicWrapperTable * pWrapperTable);
	SpecialResult loadWrapperTable(sSpecialDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	SpecialResult loadWrapperTableFromSymbolLookupMethod(sSpecialDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	static void readMethodInto(SpecialSymbolLookupType pLookupMethod, std::string sFunctionName, void** pfnTarget) {
		SpecialResult eLookupError = (*pLookupMethod)(sFunctionName.c_str(), pfnTarget);
		if ( (eLookupError != SPECIAL_SUCCESS) || (pfnTarget == nullptr) )
			throw ESpecialException(SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT, "");
	}

	friend class CBase;
	friend class CSpecialVariable;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
private:
	sSpecialFunctionTableBase* m_pFunctionTableBase;
	inline static std::map<SpecialSymbolLookupType, sSpecialFunctionTableBase>& MapFunctionTableBase()
	{
		static std::map<SpecialSymbolLookupType, sSpecialFunctionTableBase> sMapFunctionTableBase;
		return sMapFunctionTableBase;
	}
protected:
	/* Handle to Instance in library*/
	SpecialExtendedHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	virtual void CheckError(SpecialResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			GetLastError(sErrorMessage);
			throw ESpecialException(nResult, sErrorMessage);
		}
	}
public:
	/**
	* CBase::CBase - Constructor for class Base.
	*/
	CBase(SpecialExtendedHandle pHandle)
		: m_pHandle(pHandle)
	{
		SpecialSymbolLookupType pLookupFunction = m_pHandle.m_pfnSymbolLookupMethod;
		auto iFunctionTable = MapFunctionTableBase().find(pLookupFunction);
		if (MapFunctionTableBase().end() == iFunctionTable) {
			auto iNewFunctionTable = MapFunctionTableBase().insert({pLookupFunction, sSpecialFunctionTableBase()});
			m_pFunctionTableBase = &(iNewFunctionTable.first->second);
			CWrapper::readMethodInto(pLookupFunction, "special_base_getsymbollookupmethod", (void**)&(m_pFunctionTableBase->m_Base_GetSymbolLookupMethod));
			CWrapper::readMethodInto(pLookupFunction, "special_base_releaseinstance", (void**)&(m_pFunctionTableBase->m_Base_ReleaseInstance));
			CWrapper::readMethodInto(pLookupFunction, "special_base_acquireinstance", (void**)&(m_pFunctionTableBase->m_Base_AcquireInstance));
			CWrapper::readMethodInto(pLookupFunction, "special_base_getversion", (void**)&(m_pFunctionTableBase->m_Base_GetVersion));
			CWrapper::readMethodInto(pLookupFunction, "special_base_getlasterror", (void**)&(m_pFunctionTableBase->m_Base_GetLastError));
		} else {
			m_pFunctionTableBase = &(iFunctionTable->second);
		}
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		ReleaseInstance();
		m_pHandle.m_hHandle = nullptr;
		m_pHandle.m_pfnSymbolLookupMethod = nullptr;
	}

	/**
	* CBase::GetHandle - Returns handle to instance.
	*/
	SpecialExtendedHandle GetHandle()
	{
		return m_pHandle;
	}
	
	friend class CWrapper;
	inline Special_pvoid GetSymbolLookupMethod();
	inline void ReleaseInstance();
	inline void AcquireInstance();
	inline void GetVersion(Special_uint32 & nMajor, Special_uint32 & nMinor, Special_uint32 & nMicro);
	inline bool GetLastError(std::string & sErrorMessage);
};

	
/*************************************************************************************************************************
 Class CSpecialVariable 
**************************************************************************************************************************/
class CSpecialVariable : public Numbers::Binding::CVariable {
private:
	sSpecialFunctionTableSpecialVariable* m_pFunctionTableSpecialVariable;
	inline static std::map<SpecialSymbolLookupType, sSpecialFunctionTableSpecialVariable>& MapFunctionTableSpecialVariable()
	{
		static std::map<SpecialSymbolLookupType, sSpecialFunctionTableSpecialVariable> sMapFunctionTableSpecialVariable;
		return sMapFunctionTableSpecialVariable;
	}
public:
	/**
	* CSpecialVariable::CSpecialVariable - Constructor for class SpecialVariable.
	*/
	CSpecialVariable(SpecialExtendedHandle pHandle)
		: Numbers::Binding::CVariable({pHandle.m_hHandle, pHandle.m_pfnSymbolLookupMethod})
	{
		SpecialSymbolLookupType pLookupFunction = m_pHandle.m_pfnSymbolLookupMethod;
		auto iFunctionTable = MapFunctionTableSpecialVariable().find(pLookupFunction);
		if (MapFunctionTableSpecialVariable().end() == iFunctionTable) {
			auto iNewFunctionTable = MapFunctionTableSpecialVariable().insert({pLookupFunction, sSpecialFunctionTableSpecialVariable()});
			m_pFunctionTableSpecialVariable = &(iNewFunctionTable.first->second);
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getsymbollookupmethod", (void**)&(m_pFunctionTableSpecialVariable->m_Base_GetSymbolLookupMethod));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_releaseinstance", (void**)&(m_pFunctionTableSpecialVariable->m_Base_ReleaseInstance));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_acquireinstance", (void**)&(m_pFunctionTableSpecialVariable->m_Base_AcquireInstance));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getversion", (void**)&(m_pFunctionTableSpecialVariable->m_Base_GetVersion));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getlasterror", (void**)&(m_pFunctionTableSpecialVariable->m_Base_GetLastError));
			CWrapper::readMethodInto(pLookupFunction, "numbers_variable_getvalue", (void**)&(m_pFunctionTableSpecialVariable->m_Variable_GetValue));
			CWrapper::readMethodInto(pLookupFunction, "numbers_variable_setvalue", (void**)&(m_pFunctionTableSpecialVariable->m_Variable_SetValue));
			CWrapper::readMethodInto(pLookupFunction, "special_specialvariable_getspecialvalue", (void**)&(m_pFunctionTableSpecialVariable->m_SpecialVariable_GetSpecialValue));
		} else {
			m_pFunctionTableSpecialVariable = &(iFunctionTable->second);
		}
	}
	
	inline Special_int64 GetSpecialValue();
};

	
	/**
	* CWrapper::CreateSpecialVariableAsVariable - Creates a new SpecialVariable instance
	* @param[in] dInitialValue - Initial value of the new SpecialVariable
	* @return New SpecialVariable instance
	*/
	inline Numbers::Binding::PVariable CWrapper::CreateSpecialVariableAsVariable(const Special_double dInitialValue)
	{
		NumbersExtendedHandle hInstance;
		CheckError(m_WrapperTable.m_CreateSpecialVariableAsVariable(dInitialValue, &hInstance));
		
		if (!hInstance.m_hHandle) {
			CheckError(SPECIAL_ERROR_INVALIDPARAM);
		}
		return std::make_shared<Numbers::Binding::CVariable>(hInstance);
	}
	
	/**
	* CWrapper::CreateSpecialVariable - Creates a new SpecialVariable instance
	* @param[in] dInitialValue - Initial value of the new SpecialVariable
	* @return New SpecialVariable instance
	*/
	inline PSpecialVariable CWrapper::CreateSpecialVariable(const Special_double dInitialValue)
	{
		SpecialExtendedHandle hInstance;
		CheckError(m_WrapperTable.m_CreateSpecialVariable(dInitialValue, &hInstance));
		
		if (!hInstance.m_hHandle) {
			CheckError(SPECIAL_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSpecialVariable>(hInstance);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline Special_pvoid CWrapper::GetSymbolLookupMethod()
	{
		Special_pvoid resultSymbolLookupMethod = 0;
		CheckError(m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on component
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(std::string & sErrorMessage)
	{
		Special_uint32 bytesNeededErrorMessage = 0;
		Special_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(m_WrapperTable.m_GetLastError(0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(m_WrapperTable.m_GetLastError(bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(Special_uint32 & nMajor, Special_uint32 & nMinor, Special_uint32 & nMicro)
	{
		CheckError(m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	inline void CSpecialWrapper::CheckError(SpecialResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			GetLastError(sErrorMessage);
			throw ESpecialException(nResult, sErrorMessage);
		}
	}
	

	inline SpecialResult CWrapper::initWrapperTable(sSpecialDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return SPECIAL_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Base_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_Base_ReleaseInstance = nullptr;
		pWrapperTable->m_Base_AcquireInstance = nullptr;
		pWrapperTable->m_Base_GetVersion = nullptr;
		pWrapperTable->m_Base_GetLastError = nullptr;
		pWrapperTable->m_SpecialVariable_GetSpecialValue = nullptr;
		pWrapperTable->m_CreateSpecialVariableAsVariable = nullptr;
		pWrapperTable->m_CreateSpecialVariable = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		
		return SPECIAL_SUCCESS;
	}

	inline SpecialResult CWrapper::releaseWrapperTable(sSpecialDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return SPECIAL_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return SPECIAL_SUCCESS;
	}

	inline SpecialResult CWrapper::loadWrapperTable(sSpecialDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return SPECIAL_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return SPECIAL_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = (int)strlen(pLibraryFileName);
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return SPECIAL_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return SPECIAL_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return SPECIAL_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Base_GetSymbolLookupMethod = (PSpecialBase_GetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "special_base_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_Base_GetSymbolLookupMethod = (PSpecialBase_GetSymbolLookupMethodPtr) dlsym(hLibrary, "special_base_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_GetSymbolLookupMethod == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Base_ReleaseInstance = (PSpecialBase_ReleaseInstancePtr) GetProcAddress(hLibrary, "special_base_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_Base_ReleaseInstance = (PSpecialBase_ReleaseInstancePtr) dlsym(hLibrary, "special_base_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_ReleaseInstance == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Base_AcquireInstance = (PSpecialBase_AcquireInstancePtr) GetProcAddress(hLibrary, "special_base_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_Base_AcquireInstance = (PSpecialBase_AcquireInstancePtr) dlsym(hLibrary, "special_base_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_AcquireInstance == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Base_GetVersion = (PSpecialBase_GetVersionPtr) GetProcAddress(hLibrary, "special_base_getversion");
		#else // _WIN32
		pWrapperTable->m_Base_GetVersion = (PSpecialBase_GetVersionPtr) dlsym(hLibrary, "special_base_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_GetVersion == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Base_GetLastError = (PSpecialBase_GetLastErrorPtr) GetProcAddress(hLibrary, "special_base_getlasterror");
		#else // _WIN32
		pWrapperTable->m_Base_GetLastError = (PSpecialBase_GetLastErrorPtr) dlsym(hLibrary, "special_base_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_GetLastError == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SpecialVariable_GetSpecialValue = (PSpecialSpecialVariable_GetSpecialValuePtr) GetProcAddress(hLibrary, "special_specialvariable_getspecialvalue");
		#else // _WIN32
		pWrapperTable->m_SpecialVariable_GetSpecialValue = (PSpecialSpecialVariable_GetSpecialValuePtr) dlsym(hLibrary, "special_specialvariable_getspecialvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SpecialVariable_GetSpecialValue == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateSpecialVariableAsVariable = (PSpecialCreateSpecialVariableAsVariablePtr) GetProcAddress(hLibrary, "special_createspecialvariableasvariable");
		#else // _WIN32
		pWrapperTable->m_CreateSpecialVariableAsVariable = (PSpecialCreateSpecialVariableAsVariablePtr) dlsym(hLibrary, "special_createspecialvariableasvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateSpecialVariableAsVariable == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateSpecialVariable = (PSpecialCreateSpecialVariablePtr) GetProcAddress(hLibrary, "special_createspecialvariable");
		#else // _WIN32
		pWrapperTable->m_CreateSpecialVariable = (PSpecialCreateSpecialVariablePtr) dlsym(hLibrary, "special_createspecialvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateSpecialVariable == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PSpecialGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "special_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PSpecialGetSymbolLookupMethodPtr) dlsym(hLibrary, "special_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PSpecialGetLastErrorPtr) GetProcAddress(hLibrary, "special_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PSpecialGetLastErrorPtr) dlsym(hLibrary, "special_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PSpecialGetVersionPtr) GetProcAddress(hLibrary, "special_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PSpecialGetVersionPtr) dlsym(hLibrary, "special_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return SPECIAL_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return SPECIAL_SUCCESS;
	}

	inline SpecialResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sSpecialDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return SPECIAL_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return SPECIAL_ERROR_INVALIDPARAM;
		
		SpecialSymbolLookupType pLookupFunction = (SpecialSymbolLookupType)pSymbolLookupMethod;
		readMethodInto(pLookupFunction, "special_base_getsymbollookupmethod", (void**)&(pWrapperTable->m_Base_GetSymbolLookupMethod));
		readMethodInto(pLookupFunction, "special_base_releaseinstance", (void**)&(pWrapperTable->m_Base_ReleaseInstance));
		readMethodInto(pLookupFunction, "special_base_acquireinstance", (void**)&(pWrapperTable->m_Base_AcquireInstance));
		readMethodInto(pLookupFunction, "special_base_getversion", (void**)&(pWrapperTable->m_Base_GetVersion));
		readMethodInto(pLookupFunction, "special_base_getlasterror", (void**)&(pWrapperTable->m_Base_GetLastError));
		readMethodInto(pLookupFunction, "special_specialvariable_getspecialvalue", (void**)&(pWrapperTable->m_SpecialVariable_GetSpecialValue));
		readMethodInto(pLookupFunction, "special_createspecialvariableasvariable", (void**)&(pWrapperTable->m_CreateSpecialVariableAsVariable));
		readMethodInto(pLookupFunction, "special_createspecialvariable", (void**)&(pWrapperTable->m_CreateSpecialVariable));
		readMethodInto(pLookupFunction, "special_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		readMethodInto(pLookupFunction, "special_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		readMethodInto(pLookupFunction, "special_getversion", (void**)&(pWrapperTable->m_GetVersion));
		return SPECIAL_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	* CBase::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	Special_pvoid CBase::GetSymbolLookupMethod()
	{
		Special_pvoid resultSymbolLookupMethod = 0;
		CheckError(m_pFunctionTableBase->m_Base_GetSymbolLookupMethod({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, &resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CBase::ReleaseInstance - Releases shared ownership of an Instance
	*/
	void CBase::ReleaseInstance()
	{
		CheckError(m_pFunctionTableBase->m_Base_ReleaseInstance({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}));
	}
	
	/**
	* CBase::AcquireInstance - Acquires shared ownership of an Instance
	*/
	void CBase::AcquireInstance()
	{
		CheckError(m_pFunctionTableBase->m_Base_AcquireInstance({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}));
	}
	
	/**
	* CBase::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	void CBase::GetVersion(Special_uint32 & nMajor, Special_uint32 & nMinor, Special_uint32 & nMicro)
	{
		CheckError(m_pFunctionTableBase->m_Base_GetVersion({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, &nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CBase::GetLastError - Returns the last error recorded on this object
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	bool CBase::GetLastError(std::string & sErrorMessage)
	{
		Special_uint32 bytesNeededErrorMessage = 0;
		Special_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(m_pFunctionTableBase->m_Base_GetLastError({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(m_pFunctionTableBase->m_Base_GetLastError({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	 * Method definitions for class CSpecialVariable
	 */
	
	/**
	* CSpecialVariable::GetSpecialValue - Returns the current value of this Variable as integer. i.e. it rounds
	* @return The current value of this Variable
	*/
	Special_int64 CSpecialVariable::GetSpecialValue()
	{
		Special_int64 resultValue = 0;
		CheckError(m_pFunctionTableSpecialVariable->m_SpecialVariable_GetSpecialValue({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, &resultValue));
		
		return resultValue;
	}

} // namespace Binding
} // namespace Special

#endif // __SPECIAL_CPPHEADER_DYNAMIC_CPP

