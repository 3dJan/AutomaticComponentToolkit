/*++

Copyright (C) 2019 Numbers developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 2.0.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Numbers library

Interface version: 1.0.0

*/

#ifndef __NUMBERS_CPPHEADER_DYNAMIC_CPP
#define __NUMBERS_CPPHEADER_DYNAMIC_CPP

#include "numbers_types.hpp"
#include "numbers_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>
#include <map>

namespace Numbers {
namespace Binding {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CVariable;
class CVariableImpl;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CNumbersWrapper;
typedef CBase CNumbersBase;
typedef CVariable CNumbersVariable;
typedef CVariableImpl CNumbersVariableImpl;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CVariable> PVariable;
typedef std::shared_ptr<CVariableImpl> PVariableImpl;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PNumbersWrapper;
typedef PBase PNumbersBase;
typedef PVariable PNumbersVariable;
typedef PVariableImpl PNumbersVariableImpl;


/*************************************************************************************************************************
 Class ENumbersException 
**************************************************************************************************************************/
class ENumbersException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	NumbersResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ENumbersException(NumbersResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Exception Constructor.
	*/
	ENumbersException(NumbersResult errorCode)
		: ENumbersException(errorCode, "")
	{
	}

	/**
	* Returns error code
	*/
	NumbersResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case NUMBERS_SUCCESS: return "SUCCESS";
			case NUMBERS_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case NUMBERS_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case NUMBERS_ERROR_INVALIDCAST: return "INVALIDCAST";
			case NUMBERS_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case NUMBERS_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case NUMBERS_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case NUMBERS_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case NUMBERS_SUCCESS: return "success";
			case NUMBERS_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case NUMBERS_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case NUMBERS_ERROR_INVALIDCAST: return "a type cast failed";
			case NUMBERS_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case NUMBERS_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case NUMBERS_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case NUMBERS_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CNumbersInputVector = CInputVector<T>;


/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper(void* pSymbolLookupMethod)
	{
		CheckErrorSafely(initWrapperTable(&m_WrapperTable));
		CheckErrorSafely(loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckErrorSafely(checkBinaryVersion());
	}
	
	CWrapper(const std::string &sFileName)
	{
		CheckErrorSafely(initWrapperTable(&m_WrapperTable));
		CheckErrorSafely(loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckErrorSafely(checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckErrorSafely(NumbersResult nResult);
	inline void CheckError(NumbersResult nResult);

	inline bool InvestigateVariable(CVariable * pInstance);
	inline PVariable CreateVariable(const Numbers_double dInitialValue);
	inline PVariableImpl CreateVariableImpl(const Numbers_double dInitialValue);
	inline Numbers_pvoid GetSymbolLookupMethod();
	inline bool GetLastError(std::string & sErrorMessage);
	inline void GetVersion(Numbers_uint32 & nMajor, Numbers_uint32 & nMinor, Numbers_uint32 & nMicro);

private:
	sNumbersDynamicWrapperTable m_WrapperTable;
	
	NumbersResult checkBinaryVersion()
	{
		Numbers_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != NUMBERS_VERSION_MAJOR) || (nMinor < NUMBERS_VERSION_MINOR) ) {
			return NUMBERS_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return NUMBERS_SUCCESS;
	}
	NumbersResult initWrapperTable(sNumbersDynamicWrapperTable * pWrapperTable);
	NumbersResult releaseWrapperTable(sNumbersDynamicWrapperTable * pWrapperTable);
	NumbersResult loadWrapperTable(sNumbersDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	NumbersResult loadWrapperTableFromSymbolLookupMethod(sNumbersDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	static void readMethodInto(NumbersSymbolLookupType pLookupMethod, std::string sFunctionName, void** pfnTarget) {
		NumbersResult eLookupError = (*pLookupMethod)(sFunctionName.c_str(), pfnTarget);
		if ( (eLookupError != NUMBERS_SUCCESS) || (pfnTarget == nullptr) )
			throw ENumbersException(NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT, "");
	}

	static void readAbstractMethodInto(NumbersSymbolLookupType pLookupMethod, std::string sFunctionName, void** pfnTarget) {
		NumbersResult eLookupError = (*pLookupMethod)(sFunctionName.c_str(), pfnTarget);
		if (eLookupError != NUMBERS_SUCCESS)
			*pfnTarget = 0;
	}

	friend class CBase;
	friend class CVariable;
	friend class CVariableImpl;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
private:
	sNumbersFunctionTableBase* m_pFunctionTableBase;
	inline static std::map<NumbersSymbolLookupType, sNumbersFunctionTableBase>& MapFunctionTableBase()
	{
		static std::map<NumbersSymbolLookupType, sNumbersFunctionTableBase> sMapFunctionTableBase;
		return sMapFunctionTableBase;
	}
protected:
	/* Handle to Instance in library*/
	NumbersExtendedHandle m_pHandle;

	/* Checks for an Error code and raises an Exception */
	virtual void CheckErrorSafely(NumbersResult nResult)
	{
		if (nResult != 0) {
			throw ENumbersException(nResult, "");
		}
	}

	/* Checks for an Error code and error-message and raises an Exception */
	virtual void CheckError(NumbersResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			GetLastError(sErrorMessage);
			throw ENumbersException(nResult, sErrorMessage);
		}
	}
public:
	/**
	* CBase::CBase - Constructor for class Base.
	*/
	CBase(NumbersExtendedHandle pHandle)
		: m_pHandle(pHandle)
	{
		NumbersSymbolLookupType pLookupFunction = m_pHandle.m_pfnSymbolLookupMethod;
		auto iFunctionTable = MapFunctionTableBase().find(pLookupFunction);
		if (MapFunctionTableBase().end() == iFunctionTable) {
			auto iNewFunctionTable = MapFunctionTableBase().insert({pLookupFunction, sNumbersFunctionTableBase()});
			m_pFunctionTableBase = &(iNewFunctionTable.first->second);
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getsymbollookupmethod", (void**)&(m_pFunctionTableBase->m_Base_GetSymbolLookupMethod));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_releaseinstance", (void**)&(m_pFunctionTableBase->m_Base_ReleaseInstance));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_acquireinstance", (void**)&(m_pFunctionTableBase->m_Base_AcquireInstance));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getversion", (void**)&(m_pFunctionTableBase->m_Base_GetVersion));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getlasterror", (void**)&(m_pFunctionTableBase->m_Base_GetLastError));
		} else {
			m_pFunctionTableBase = &(iFunctionTable->second);
		}
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		ReleaseInstance();
		m_pHandle.m_hHandle = nullptr;
		m_pHandle.m_pfnSymbolLookupMethod = nullptr;
	}

	/**
	* CBase::GetHandle - Returns handle to instance.
	*/
	NumbersExtendedHandle GetHandle()
	{
		return m_pHandle;
	}
	
	friend class CWrapper;
	inline Numbers_pvoid GetSymbolLookupMethod();
	inline void ReleaseInstance();
	inline void AcquireInstance();
	inline void GetVersion(Numbers_uint32 & nMajor, Numbers_uint32 & nMinor, Numbers_uint32 & nMicro);
	inline bool GetLastError(std::string & sErrorMessage);
};

	
/*************************************************************************************************************************
 Class CVariable 
**************************************************************************************************************************/
class CVariable : public CBase {
private:
	sNumbersFunctionTableVariable* m_pFunctionTableVariable;
	inline static std::map<NumbersSymbolLookupType, sNumbersFunctionTableVariable>& MapFunctionTableVariable()
	{
		static std::map<NumbersSymbolLookupType, sNumbersFunctionTableVariable> sMapFunctionTableVariable;
		return sMapFunctionTableVariable;
	}
public:
	/**
	* CVariable::CVariable - Constructor for class Variable.
	*/
	CVariable(NumbersExtendedHandle pHandle)
		: CBase(pHandle)
	{
		NumbersSymbolLookupType pLookupFunction = m_pHandle.m_pfnSymbolLookupMethod;
		auto iFunctionTable = MapFunctionTableVariable().find(pLookupFunction);
		if (MapFunctionTableVariable().end() == iFunctionTable) {
			auto iNewFunctionTable = MapFunctionTableVariable().insert({pLookupFunction, sNumbersFunctionTableVariable()});
			m_pFunctionTableVariable = &(iNewFunctionTable.first->second);
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getsymbollookupmethod", (void**)&(m_pFunctionTableVariable->m_Base_GetSymbolLookupMethod));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_releaseinstance", (void**)&(m_pFunctionTableVariable->m_Base_ReleaseInstance));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_acquireinstance", (void**)&(m_pFunctionTableVariable->m_Base_AcquireInstance));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getversion", (void**)&(m_pFunctionTableVariable->m_Base_GetVersion));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getlasterror", (void**)&(m_pFunctionTableVariable->m_Base_GetLastError));
			CWrapper::readAbstractMethodInto(pLookupFunction, "numbers_variable_getvalue", (void**)&(m_pFunctionTableVariable->m_Variable_GetValue));
			CWrapper::readAbstractMethodInto(pLookupFunction, "numbers_variable_setvalue", (void**)&(m_pFunctionTableVariable->m_Variable_SetValue));
		} else {
			m_pFunctionTableVariable = &(iFunctionTable->second);
		}
	}
	
	inline Numbers_double GetValue();
	inline void SetValue(const Numbers_double dValue);
};

	
/*************************************************************************************************************************
 Class CVariableImpl 
**************************************************************************************************************************/
class CVariableImpl : public CVariable {
private:
	sNumbersFunctionTableVariableImpl* m_pFunctionTableVariableImpl;
	inline static std::map<NumbersSymbolLookupType, sNumbersFunctionTableVariableImpl>& MapFunctionTableVariableImpl()
	{
		static std::map<NumbersSymbolLookupType, sNumbersFunctionTableVariableImpl> sMapFunctionTableVariableImpl;
		return sMapFunctionTableVariableImpl;
	}
public:
	/**
	* CVariableImpl::CVariableImpl - Constructor for class VariableImpl.
	*/
	CVariableImpl(NumbersExtendedHandle pHandle)
		: CVariable(pHandle)
	{
		NumbersSymbolLookupType pLookupFunction = m_pHandle.m_pfnSymbolLookupMethod;
		auto iFunctionTable = MapFunctionTableVariableImpl().find(pLookupFunction);
		if (MapFunctionTableVariableImpl().end() == iFunctionTable) {
			auto iNewFunctionTable = MapFunctionTableVariableImpl().insert({pLookupFunction, sNumbersFunctionTableVariableImpl()});
			m_pFunctionTableVariableImpl = &(iNewFunctionTable.first->second);
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getsymbollookupmethod", (void**)&(m_pFunctionTableVariableImpl->m_Base_GetSymbolLookupMethod));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_releaseinstance", (void**)&(m_pFunctionTableVariableImpl->m_Base_ReleaseInstance));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_acquireinstance", (void**)&(m_pFunctionTableVariableImpl->m_Base_AcquireInstance));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getversion", (void**)&(m_pFunctionTableVariableImpl->m_Base_GetVersion));
			CWrapper::readMethodInto(pLookupFunction, "numbers_base_getlasterror", (void**)&(m_pFunctionTableVariableImpl->m_Base_GetLastError));
			CWrapper::readAbstractMethodInto(pLookupFunction, "numbers_variable_getvalue", (void**)&(m_pFunctionTableVariableImpl->m_Variable_GetValue));
			CWrapper::readAbstractMethodInto(pLookupFunction, "numbers_variable_setvalue", (void**)&(m_pFunctionTableVariableImpl->m_Variable_SetValue));
		} else {
			m_pFunctionTableVariableImpl = &(iFunctionTable->second);
		}
	}
	
};

	
	/**
	* CWrapper::InvestigateVariable - Checks whether a variable is an Instance of VariableImpl
	* @param[in] pInstance - Checks 
	* @return Is this variable an Instance of VariableImpl?
	*/
	inline bool CWrapper::InvestigateVariable(CVariable * pInstance)
	{
		NumbersExtendedHandle hInstance;
		if (pInstance != nullptr) {
			hInstance = pInstance->GetHandle();
		};
		bool resultIsImpl = 0;
		CheckError(m_WrapperTable.m_InvestigateVariable(hInstance, &resultIsImpl));
		
		return resultIsImpl;
	}
	
	/**
	* CWrapper::CreateVariable - Creates a new Variable instance
	* @param[in] dInitialValue - Initial value of the new Variable
	* @return New Variable instance
	*/
	inline PVariable CWrapper::CreateVariable(const Numbers_double dInitialValue)
	{
		NumbersExtendedHandle hInstance;
		CheckError(m_WrapperTable.m_CreateVariable(dInitialValue, &hInstance));
		
		if (!hInstance.m_hHandle) {
			CheckError(NUMBERS_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CVariable>(hInstance);
	}
	
	/**
	* CWrapper::CreateVariableImpl - Creates a new Variable instance
	* @param[in] dInitialValue - Initial value of the new Variable
	* @return New Variable instance
	*/
	inline PVariableImpl CWrapper::CreateVariableImpl(const Numbers_double dInitialValue)
	{
		NumbersExtendedHandle hInstance;
		CheckError(m_WrapperTable.m_CreateVariableImpl(dInitialValue, &hInstance));
		
		if (!hInstance.m_hHandle) {
			CheckError(NUMBERS_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CVariableImpl>(hInstance);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline Numbers_pvoid CWrapper::GetSymbolLookupMethod()
	{
		Numbers_pvoid resultSymbolLookupMethod = 0;
		CheckErrorSafely(m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on component
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(std::string & sErrorMessage)
	{
		Numbers_uint32 bytesNeededErrorMessage = 0;
		Numbers_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckErrorSafely(m_WrapperTable.m_GetLastError(0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckErrorSafely(m_WrapperTable.m_GetLastError(bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(Numbers_uint32 & nMajor, Numbers_uint32 & nMinor, Numbers_uint32 & nMicro)
	{
		CheckErrorSafely(m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	inline void CWrapper::CheckErrorSafely(NumbersResult nResult)
	{
		if (nResult != 0) {
			throw ENumbersException(nResult, "");
		}
	}
	
	inline void CWrapper::CheckError(NumbersResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			GetLastError(sErrorMessage);
			throw ENumbersException(nResult, sErrorMessage);
		}
	}
	

	inline NumbersResult CWrapper::initWrapperTable(sNumbersDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return NUMBERS_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Base_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_Base_ReleaseInstance = nullptr;
		pWrapperTable->m_Base_AcquireInstance = nullptr;
		pWrapperTable->m_Base_GetVersion = nullptr;
		pWrapperTable->m_Base_GetLastError = nullptr;
		pWrapperTable->m_Variable_GetValue = nullptr;
		pWrapperTable->m_Variable_SetValue = nullptr;
		pWrapperTable->m_InvestigateVariable = nullptr;
		pWrapperTable->m_CreateVariable = nullptr;
		pWrapperTable->m_CreateVariableImpl = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		
		return NUMBERS_SUCCESS;
	}

	inline NumbersResult CWrapper::releaseWrapperTable(sNumbersDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return NUMBERS_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return NUMBERS_SUCCESS;
	}

	inline NumbersResult CWrapper::loadWrapperTable(sNumbersDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return NUMBERS_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return NUMBERS_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = (int)strlen(pLibraryFileName);
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return NUMBERS_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return NUMBERS_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return NUMBERS_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Base_GetSymbolLookupMethod = (PNumbersBase_GetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "numbers_base_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_Base_GetSymbolLookupMethod = (PNumbersBase_GetSymbolLookupMethodPtr) dlsym(hLibrary, "numbers_base_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_GetSymbolLookupMethod == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Base_ReleaseInstance = (PNumbersBase_ReleaseInstancePtr) GetProcAddress(hLibrary, "numbers_base_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_Base_ReleaseInstance = (PNumbersBase_ReleaseInstancePtr) dlsym(hLibrary, "numbers_base_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_ReleaseInstance == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Base_AcquireInstance = (PNumbersBase_AcquireInstancePtr) GetProcAddress(hLibrary, "numbers_base_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_Base_AcquireInstance = (PNumbersBase_AcquireInstancePtr) dlsym(hLibrary, "numbers_base_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_AcquireInstance == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Base_GetVersion = (PNumbersBase_GetVersionPtr) GetProcAddress(hLibrary, "numbers_base_getversion");
		#else // _WIN32
		pWrapperTable->m_Base_GetVersion = (PNumbersBase_GetVersionPtr) dlsym(hLibrary, "numbers_base_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_GetVersion == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Base_GetLastError = (PNumbersBase_GetLastErrorPtr) GetProcAddress(hLibrary, "numbers_base_getlasterror");
		#else // _WIN32
		pWrapperTable->m_Base_GetLastError = (PNumbersBase_GetLastErrorPtr) dlsym(hLibrary, "numbers_base_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Base_GetLastError == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InvestigateVariable = (PNumbersInvestigateVariablePtr) GetProcAddress(hLibrary, "numbers_investigatevariable");
		#else // _WIN32
		pWrapperTable->m_InvestigateVariable = (PNumbersInvestigateVariablePtr) dlsym(hLibrary, "numbers_investigatevariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InvestigateVariable == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateVariable = (PNumbersCreateVariablePtr) GetProcAddress(hLibrary, "numbers_createvariable");
		#else // _WIN32
		pWrapperTable->m_CreateVariable = (PNumbersCreateVariablePtr) dlsym(hLibrary, "numbers_createvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateVariable == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateVariableImpl = (PNumbersCreateVariableImplPtr) GetProcAddress(hLibrary, "numbers_createvariableimpl");
		#else // _WIN32
		pWrapperTable->m_CreateVariableImpl = (PNumbersCreateVariableImplPtr) dlsym(hLibrary, "numbers_createvariableimpl");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateVariableImpl == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PNumbersGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "numbers_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PNumbersGetSymbolLookupMethodPtr) dlsym(hLibrary, "numbers_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PNumbersGetLastErrorPtr) GetProcAddress(hLibrary, "numbers_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PNumbersGetLastErrorPtr) dlsym(hLibrary, "numbers_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PNumbersGetVersionPtr) GetProcAddress(hLibrary, "numbers_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PNumbersGetVersionPtr) dlsym(hLibrary, "numbers_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return NUMBERS_SUCCESS;
	}

	inline NumbersResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sNumbersDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return NUMBERS_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return NUMBERS_ERROR_INVALIDPARAM;
		
		NumbersSymbolLookupType pLookupFunction = (NumbersSymbolLookupType)pSymbolLookupMethod;
		readMethodInto(pLookupFunction, "numbers_base_getsymbollookupmethod", (void**)&(pWrapperTable->m_Base_GetSymbolLookupMethod));
		readMethodInto(pLookupFunction, "numbers_base_releaseinstance", (void**)&(pWrapperTable->m_Base_ReleaseInstance));
		readMethodInto(pLookupFunction, "numbers_base_acquireinstance", (void**)&(pWrapperTable->m_Base_AcquireInstance));
		readMethodInto(pLookupFunction, "numbers_base_getversion", (void**)&(pWrapperTable->m_Base_GetVersion));
		readMethodInto(pLookupFunction, "numbers_base_getlasterror", (void**)&(pWrapperTable->m_Base_GetLastError));
		readMethodInto(pLookupFunction, "numbers_investigatevariable", (void**)&(pWrapperTable->m_InvestigateVariable));
		readMethodInto(pLookupFunction, "numbers_createvariable", (void**)&(pWrapperTable->m_CreateVariable));
		readMethodInto(pLookupFunction, "numbers_createvariableimpl", (void**)&(pWrapperTable->m_CreateVariableImpl));
		readMethodInto(pLookupFunction, "numbers_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		readMethodInto(pLookupFunction, "numbers_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		readMethodInto(pLookupFunction, "numbers_getversion", (void**)&(pWrapperTable->m_GetVersion));
		return NUMBERS_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	* CBase::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	Numbers_pvoid CBase::GetSymbolLookupMethod()
	{
		Numbers_pvoid resultSymbolLookupMethod = 0;
		CheckErrorSafely(m_pFunctionTableBase->m_Base_GetSymbolLookupMethod({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, &resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CBase::ReleaseInstance - Releases shared ownership of an Instance
	*/
	void CBase::ReleaseInstance()
	{
		CheckError(m_pFunctionTableBase->m_Base_ReleaseInstance({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}));
	}
	
	/**
	* CBase::AcquireInstance - Acquires shared ownership of an Instance
	*/
	void CBase::AcquireInstance()
	{
		CheckError(m_pFunctionTableBase->m_Base_AcquireInstance({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}));
	}
	
	/**
	* CBase::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	void CBase::GetVersion(Numbers_uint32 & nMajor, Numbers_uint32 & nMinor, Numbers_uint32 & nMicro)
	{
		CheckErrorSafely(m_pFunctionTableBase->m_Base_GetVersion({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, &nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CBase::GetLastError - Returns the last error recorded on this object
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	bool CBase::GetLastError(std::string & sErrorMessage)
	{
		Numbers_uint32 bytesNeededErrorMessage = 0;
		Numbers_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckErrorSafely(m_pFunctionTableBase->m_Base_GetLastError({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckErrorSafely(m_pFunctionTableBase->m_Base_GetLastError({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	 * Method definitions for class CVariable
	 */
	
	/**
	* CVariable::GetValue - Returns the current value of this Variable
	* @return The current value of this Variable
	*/
	Numbers_double CVariable::GetValue()
	{
		Numbers_double resultValue = 0;
		if (!m_pFunctionTableVariable->m_Variable_GetValue)
			throw ENumbersException(NUMBERS_ERROR_NOTIMPLEMENTED, "Method 'GetValue' not found");
		CheckError(m_pFunctionTableVariable->m_Variable_GetValue({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CVariable::SetValue - Set the numerical value of this Variable
	* @param[in] dValue - The new value of this Variable
	*/
	void CVariable::SetValue(const Numbers_double dValue)
	{
		if (!m_pFunctionTableVariable->m_Variable_SetValue)
			throw ENumbersException(NUMBERS_ERROR_NOTIMPLEMENTED, "Method 'SetValue' not found");
		CheckError(m_pFunctionTableVariable->m_Variable_SetValue({m_pHandle.m_hHandle, m_pHandle.m_pfnSymbolLookupMethod}, dValue));
	}
	
	/**
	 * Method definitions for class CVariableImpl
	 */

} // namespace Binding
} // namespace Numbers



/*************************************************************************************************************************
Client implementation
**************************************************************************************************************************/

namespace Numbers {
namespace Binding {
namespace ClientImpl {

// Create a wrapped instance of a client implementation class. This means
// constructing a client implementation class instance, forwarding arguments
// passed to the function, which is then wrapped in a new binding instance of
// the appropriate type. The result can thus be passed into functions that deal
// in binding types.
template <typename tCLASS, typename... tARGS>                         
static typename tCLASS::tBINDING_PTR CreateWrappedInstance(tARGS&&... args)
{          
  auto ptr = std::make_unique<tCLASS>(std::forward<tARGS>(args)...);  
  ptr->AcquireInstance(); // CBase ctor doesn't acquire         
  return typename tCLASS::tBINDING_PTR(
    new typename tCLASS::tBINDING_CLASS(ptr.release()->GetExtendedHandle())
  );
}

// Given a pointer to a binding object, cast the wrapped handle to a client
// implementation instance. The caller is responsible for ensuring that the
// binding object really does wrap a client implementation.
template <typename tCLASS>
static tCLASS* UnsafeGetWrappedInstance(typename tCLASS::tBINDING_PTR pBindingPtr)
{
  return UnsafeGetWrappedInstance<tCLASS>(pBindingPtr->GetHandle());
}

// Cast a handle to a client implementation instance. The caller is responsible for
// ensuring that the binding object really does wrap a client implementation.
template <typename tCLASS>
static tCLASS* UnsafeGetWrappedInstance(NumbersExtendedHandle extendedHandle)
{
  return UnsafeGetWrappedInstance<tCLASS>(extendedHandle.m_hHandle);
}

// Cast a handle to a client implementation instance. The caller is responsible for
// ensuring that the binding object really does wrap a client implementation.
template <typename tCLASS>
static tCLASS* UnsafeGetWrappedInstance(NumbersHandle handle)
{
  return (tCLASS*) handle;
}

// Static handler for ENumbersException from client impl abi wrapper function.
// TODO: propagate error code / info
template <typename tCLASS>
NumbersResult handleNumbersException(tCLASS* object, const ENumbersException& e)
{
  return e.getErrorCode();
}

// Static handler for std::exception from client impl abi wrapper function.
// TODO: propagate error code / info
template <typename tCLASS>
NumbersResult handleStdException(tCLASS* object, const std::exception& e)
{
  return NUMBERS_ERROR_GENERICEXCEPTION;
}

// Static handler for generic exception from client impl abi wrapper function.
// TODO: propagate error code / info
template <typename tCLASS>
NumbersResult handleUnhandledException(tCLASS* object)
{
  return NUMBERS_ERROR_GENERICEXCEPTION;
}

// Utility method for SymbolLookupFunction_ABI. Attempt to find the symbol in 
// the map, outputting it if present, and returning an appropriate error code if
// not.
inline static NumbersResult LookupSymbolInMap(
  const char* pProcName, 
  std::map<std::string, void*>& procAddressMap, 
  void** ppProcAddress
)
{
    try {
        if (pProcName == nullptr)
            return NUMBERS_ERROR_INVALIDPARAM;
        if (ppProcAddress == nullptr)
            return NUMBERS_ERROR_INVALIDPARAM;
        auto it = procAddressMap.find(pProcName);
        *ppProcAddress = it != end(procAddressMap) ? it->second : nullptr;
        if (!*ppProcAddress) {
            return NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT;
        }
    } catch (Numbers::Binding::ENumbersException&) {
        return NUMBERS_ERROR_GENERICEXCEPTION;
    } catch (std::exception&) {
        return NUMBERS_ERROR_GENERICEXCEPTION;
    } catch (...) {
        return NUMBERS_ERROR_GENERICEXCEPTION;
    }
    return NUMBERS_SUCCESS;
}

/*************************************************************************************************************************
 Class CBase
**************************************************************************************************************************/
class CBase {
public:

  // Associated types.  These are used by certain template functions.
  using tBINDING_PTR = Numbers::Binding::PBase;
  using tBINDING_CLASS = Numbers::Binding::CBase;

  // Default constructor.
  inline CBase();

  // Copying is prohibited
  CBase(const CBase& that) = delete;

  // Assignment is prohibited
  CBase& operator=(const CBase& that) = delete;

  // Destructor
  inline virtual ~CBase();

  // Get the extended handle for this instance. The extended handle can
  // be wrapped in a tBINDING_CLASS instance and passed into binding
  // methods as a parameter.
  inline NumbersExtendedHandle GetExtendedHandle() const;

  // API methods

	inline virtual Numbers_pvoid GetSymbolLookupMethod();

	inline virtual void ReleaseInstance();

	inline virtual void AcquireInstance();

	inline virtual void GetVersion(Numbers_uint32 & nMajor, Numbers_uint32 & nMinor, Numbers_uint32 & nMicro);

	inline virtual bool GetLastError(std::string & sErrorMessage);

protected:
    
  // Symbol lookup function for the methods on this class. Looks up the _ABI
  // functions of this class by name.    Derived classes must add their own
  // symbol lookup function exposing their own functions, which should call
  // down to this function when a symbol cannot be found.
  inline static NumbersResult SymbolLookupFunction_ABI(
    const char* pProcName, 
    void** ppProcAddress
  );
	
	/**
	* Returns the address of the SymbolLookupMethod
	*
	* @param[in] pBase - Base instance.
	* @param[out] pSymbolLookupMethod - Address of the SymbolAddressMethod
	* @return error code or 0 (success)
	*/
	inline static NumbersResult GetSymbolLookupMethod_ABI(Numbers_Base pBase, Numbers_pvoid * pSymbolLookupMethod);
	
	/**
	* Releases shared ownership of an Instance
	*
	* @param[in] pBase - Base instance.
	* @return error code or 0 (success)
	*/
	inline static NumbersResult ReleaseInstance_ABI(Numbers_Base pBase);
	
	/**
	* Acquires shared ownership of an Instance
	*
	* @param[in] pBase - Base instance.
	* @return error code or 0 (success)
	*/
	inline static NumbersResult AcquireInstance_ABI(Numbers_Base pBase);
	
	/**
	* retrieves the binary version of this library.
	*
	* @param[in] pBase - Base instance.
	* @param[out] pMajor - returns the major version of this library
	* @param[out] pMinor - returns the minor version of this library
	* @param[out] pMicro - returns the micro version of this library
	* @return error code or 0 (success)
	*/
	inline static NumbersResult GetVersion_ABI(Numbers_Base pBase, Numbers_uint32 * pMajor, Numbers_uint32 * pMinor, Numbers_uint32 * pMicro);
	
	/**
	* Returns the last error recorded on this object
	*
	* @param[in] pBase - Base instance.
	* @param[in] nErrorMessageBufferSize - size of the buffer (including trailing 0)
	* @param[out] pErrorMessageNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pErrorMessageBuffer -  buffer of Message of the last error, may be NULL
	* @param[out] pHasError - Is there a last error to query
	* @return error code or 0 (success)
	*/
	inline static NumbersResult GetLastError_ABI(Numbers_Base pBase, const Numbers_uint32 nErrorMessageBufferSize, Numbers_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError);

private:
  // Reference count
  Numbers_uint64 m_refcount;
};

/*************************************************************************************************************************
 Class CVariable
**************************************************************************************************************************/
class CVariable : public CBase {
public:

  // Associated types.  These are used by certain template functions.
  using tBINDING_PTR = Numbers::Binding::PVariable;
  using tBINDING_CLASS = Numbers::Binding::CVariable;
  using tBASE = Numbers::Binding::ClientImpl::CBase;

  // Default constructor.
  inline CVariable();

  // Copying is prohibited
  CVariable(const CVariable& that) = delete;

  // Assignment is prohibited
  CVariable& operator=(const CVariable& that) = delete;

  // Destructor
  inline virtual ~CVariable() override;

  // Return the symbol lookup method for this class.    In a derived
  // class, this is overridden to return a function that exposes the
  // symbols of that class, calling down to the base class function
  // if a symbol is not found.
  inline virtual Numbers_pvoid GetSymbolLookupMethod() override;

  // API methods

	inline virtual Numbers_double GetValue();

	inline virtual void SetValue(const Numbers_double dValue);

protected:
    
  // Symbol lookup function for the methods on this class. Looks up the _ABI
  // functions of this class by name.    Derived classes must add their own
  // symbol lookup function exposing their own functions, which should call
  // down to this function when a symbol cannot be found.
  inline static NumbersResult SymbolLookupFunction_ABI(
    const char* pProcName, 
    void** ppProcAddress
  );
	
	/**
	* Returns the current value of this Variable
	*
	* @param[in] pVariable - Variable instance.
	* @param[out] pValue - The current value of this Variable
	* @return error code or 0 (success)
	*/
	inline static NumbersResult GetValue_ABI(Numbers_Variable pVariable, Numbers_double * pValue);
	
	/**
	* Set the numerical value of this Variable
	*
	* @param[in] pVariable - Variable instance.
	* @param[in] dValue - The new value of this Variable
	* @return error code or 0 (success)
	*/
	inline static NumbersResult SetValue_ABI(Numbers_Variable pVariable, Numbers_double dValue);

private:
};


/*************************************************************************************************************************
CBase Implementation
**************************************************************************************************************************/

inline CBase::CBase()
: m_refcount(0)
{
}

inline CBase::~CBase()
{
}

inline Numbers_pvoid CBase::GetSymbolLookupMethod()
{
  return (Numbers_pvoid) &SymbolLookupFunction_ABI;
}

inline NumbersExtendedHandle CBase::GetExtendedHandle() const
{
    return { (void*) this, (NumbersSymbolLookupType) const_cast<CBase*>(this)->GetSymbolLookupMethod()};
}

inline bool CBase::GetLastError(std::string & sErrorMessage)
{
  return false;
}

inline void CBase::ReleaseInstance()
{
  --m_refcount;
  if (m_refcount == 0) {
    delete this;
  }
}

inline void CBase::AcquireInstance()
{
  ++m_refcount;
}

inline void CBase::GetVersion(
  Numbers_uint32 & nMajor, 
  Numbers_uint32 & nMinor,
  Numbers_uint32 & nMicro
)
{
  nMajor = NUMBERS_VERSION_MAJOR;
  nMinor = NUMBERS_VERSION_MINOR;
  nMicro = NUMBERS_VERSION_MICRO;
}

inline NumbersResult CBase::SymbolLookupFunction_ABI(
  const char* pProcName, 
  void** ppProcAddress
)
{
  static std::map<std::string, void*> sProcAddressMap;
  if (sProcAddressMap.empty()) {
		sProcAddressMap["numbers_base_getsymbollookupmethod"] = (void*) &GetSymbolLookupMethod_ABI;
		sProcAddressMap["numbers_base_releaseinstance"] = (void*) &ReleaseInstance_ABI;
		sProcAddressMap["numbers_base_acquireinstance"] = (void*) &AcquireInstance_ABI;
		sProcAddressMap["numbers_base_getversion"] = (void*) &GetVersion_ABI;
		sProcAddressMap["numbers_base_getlasterror"] = (void*) &GetLastError_ABI;
	}
  return LookupSymbolInMap(pProcName, sProcAddressMap, ppProcAddress);
}

/*************************************************************************************************************************
 CBase API-methods
**************************************************************************************************************************/


/*************************************************************************************************************************
 CBase ABI-methods
**************************************************************************************************************************/

inline NumbersResult CBase::GetSymbolLookupMethod_ABI(Numbers_Base pBase, Numbers_pvoid * pSymbolLookupMethod)
{
	CBase* pIBaseClass = UnsafeGetWrappedInstance<CBase>(pBase);

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ENumbersException (NUMBERS_ERROR_INVALIDPARAM);
		CBase* pIBase = dynamic_cast<CBase*>(pIBaseClass);
		if (!pIBase)
			throw ENumbersException(NUMBERS_ERROR_INVALIDCAST);
		
		*pSymbolLookupMethod = pIBase->GetSymbolLookupMethod();

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

inline NumbersResult CBase::ReleaseInstance_ABI(Numbers_Base pBase)
{
	CBase* pIBaseClass = UnsafeGetWrappedInstance<CBase>(pBase);

	try {
		CBase* pIBase = dynamic_cast<CBase*>(pIBaseClass);
		if (!pIBase)
			throw ENumbersException(NUMBERS_ERROR_INVALIDCAST);
		
		pIBase->ReleaseInstance();

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

inline NumbersResult CBase::AcquireInstance_ABI(Numbers_Base pBase)
{
	CBase* pIBaseClass = UnsafeGetWrappedInstance<CBase>(pBase);

	try {
		CBase* pIBase = dynamic_cast<CBase*>(pIBaseClass);
		if (!pIBase)
			throw ENumbersException(NUMBERS_ERROR_INVALIDCAST);
		
		pIBase->AcquireInstance();

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

inline NumbersResult CBase::GetVersion_ABI(Numbers_Base pBase, Numbers_uint32 * pMajor, Numbers_uint32 * pMinor, Numbers_uint32 * pMicro)
{
	CBase* pIBaseClass = UnsafeGetWrappedInstance<CBase>(pBase);

	try {
		if (!pMajor)
			throw ENumbersException (NUMBERS_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ENumbersException (NUMBERS_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ENumbersException (NUMBERS_ERROR_INVALIDPARAM);
		CBase* pIBase = dynamic_cast<CBase*>(pIBaseClass);
		if (!pIBase)
			throw ENumbersException(NUMBERS_ERROR_INVALIDCAST);
		
		pIBase->GetVersion(*pMajor, *pMinor, *pMicro);

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

inline NumbersResult CBase::GetLastError_ABI(Numbers_Base pBase, const Numbers_uint32 nErrorMessageBufferSize, Numbers_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	CBase* pIBaseClass = UnsafeGetWrappedInstance<CBase>(pBase);

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ENumbersException (NUMBERS_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ENumbersException (NUMBERS_ERROR_INVALIDPARAM);
		std::string sErrorMessage("");
		CBase* pIBase = dynamic_cast<CBase*>(pIBaseClass);
		if (!pIBase)
			throw ENumbersException(NUMBERS_ERROR_INVALIDCAST);
		
		*pHasError = pIBase->GetLastError(sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (Numbers_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ENumbersException (NUMBERS_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return NUMBERS_SUCCESS;
	}
	catch (ENumbersException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
CVariable Implementation
**************************************************************************************************************************/

inline CVariable::CVariable()
{
}

inline CVariable::~CVariable()
{
}

inline Numbers_pvoid CVariable::GetSymbolLookupMethod()
{
  return (Numbers_pvoid) &SymbolLookupFunction_ABI;
}

inline NumbersResult CVariable::SymbolLookupFunction_ABI(
  const char* pProcName, 
  void** ppProcAddress
)
{
  static std::map<std::string, void*> sProcAddressMap;
  if (sProcAddressMap.empty()) {
		sProcAddressMap["numbers_variable_getvalue"] = (void*) &GetValue_ABI;
		sProcAddressMap["numbers_variable_setvalue"] = (void*) &SetValue_ABI;
	}
  NumbersResult ret = LookupSymbolInMap(pProcName, sProcAddressMap, ppProcAddress);
  if (ret == NUMBERS_ERROR_COULDNOTFINDLIBRARYEXPORT) {
      ret = tBASE::SymbolLookupFunction_ABI(pProcName, ppProcAddress);
  }
  return ret;
}

/*************************************************************************************************************************
 CVariable API-methods
**************************************************************************************************************************/


inline Numbers_double CVariable::GetValue()
{
  throw ENumbersException(NUMBERS_ERROR_NOTIMPLEMENTED, "");
}


inline void CVariable::SetValue(const Numbers_double dValue)
{
  throw ENumbersException(NUMBERS_ERROR_NOTIMPLEMENTED, "");
}


/*************************************************************************************************************************
 CVariable ABI-methods
**************************************************************************************************************************/

inline NumbersResult CVariable::GetValue_ABI(Numbers_Variable pVariable, Numbers_double * pValue)
{
	CBase* pIBaseClass = UnsafeGetWrappedInstance<CBase>(pVariable);

	try {
		if (pValue == nullptr)
			throw ENumbersException (NUMBERS_ERROR_INVALIDPARAM);
		CVariable* pIVariable = dynamic_cast<CVariable*>(pIBaseClass);
		if (!pIVariable)
			throw ENumbersException(NUMBERS_ERROR_INVALIDCAST);
		
		*pValue = pIVariable->GetValue();

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

inline NumbersResult CVariable::SetValue_ABI(Numbers_Variable pVariable, Numbers_double dValue)
{
	CBase* pIBaseClass = UnsafeGetWrappedInstance<CBase>(pVariable);

	try {
		CVariable* pIVariable = dynamic_cast<CVariable*>(pIBaseClass);
		if (!pIVariable)
			throw ENumbersException(NUMBERS_ERROR_INVALIDCAST);
		
		pIVariable->SetValue(dValue);

		return NUMBERS_SUCCESS;
	}
	catch (ENumbersException & Exception) {
		return handleNumbersException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


} // namespace ClientImpl
} // namespace Binding
} // namespace Numbers

#endif // __NUMBERS_CPPHEADER_DYNAMIC_CPP

