/*++

Copyright (C) 2021 ADSK

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Go wrapper file in order to allow an easy
use of RTTI.

Interface version: 1.0.0

*/

// Code generated by Automatic Component Toolkit (ACT); DO NOT EDIT.

package rtti

/*
#cgo linux LDFLAGS: -ldl
#include "rtti_dynamic.cc"

RTTIHandle loadRTTILibrary (const char * pFileName)
{
	RTTIResult nResult;
	sRTTIDynamicWrapperTable * pWrapperTable = (sRTTIDynamicWrapperTable *) malloc (sizeof (sRTTIDynamicWrapperTable));
	if (pWrapperTable != NULL) {
		nResult = InitRTTIWrapperTable (pWrapperTable);
		if (nResult != RTTI_SUCCESS) {
			free (pWrapperTable);
			return 0;
		}

		nResult = LoadRTTIWrapperTable (pWrapperTable, pFileName);
		if (nResult != RTTI_SUCCESS) {
			free (pWrapperTable);
			return 0;
		}

		return (RTTIHandle) pWrapperTable;
	}
}

void unloadRTTILibrary (RTTIHandle nLibraryHandle)
{
	sRTTIDynamicWrapperTable * pWrapperTable = (sRTTIDynamicWrapperTable *) malloc (sizeof (sRTTIDynamicWrapperTable));
	if (pWrapperTable != NULL) {
		ReleaseRTTIWrapperTable (pWrapperTable);
		free (pWrapperTable);
	}
}


RTTIResult CCall_rtti_base_classtypeid(RTTIHandle libraryHandle, RTTI_Base pBase, RTTI_uint64 * pClassTypeId)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Base_ClassTypeId (pBase, pClassTypeId);
}


RTTIResult CCall_rtti_animal_name(RTTIHandle libraryHandle, RTTI_Animal pAnimal, const RTTI_uint32 nResultBufferSize, RTTI_uint32* pResultNeededChars, char * pResultBuffer)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Animal_Name (pAnimal, nResultBufferSize, pResultNeededChars, pResultBuffer);
}


RTTIResult CCall_rtti_tiger_roar(RTTIHandle libraryHandle, RTTI_Tiger pTiger)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Tiger_Roar (pTiger);
}


RTTIResult CCall_rtti_animaliterator_getnextanimal(RTTIHandle libraryHandle, RTTI_AnimalIterator pAnimalIterator, RTTI_Animal * pAnimal)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_AnimalIterator_GetNextAnimal (pAnimalIterator, pAnimal);
}


RTTIResult CCall_rtti_zoo_iterator(RTTIHandle libraryHandle, RTTI_Zoo pZoo, RTTI_AnimalIterator * pIterator)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Zoo_Iterator (pZoo, pIterator);
}


RTTIResult CCall_rtti_getversion(RTTIHandle libraryHandle, RTTI_uint32 * pMajor, RTTI_uint32 * pMinor, RTTI_uint32 * pMicro)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetVersion (pMajor, pMinor, pMicro);
}


RTTIResult CCall_rtti_getlasterror(RTTIHandle libraryHandle, RTTI_Base pInstance, const RTTI_uint32 nErrorMessageBufferSize, RTTI_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetLastError (pInstance, nErrorMessageBufferSize, pErrorMessageNeededChars, pErrorMessageBuffer, pHasError);
}


RTTIResult CCall_rtti_releaseinstance(RTTIHandle libraryHandle, RTTI_Base pInstance)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_ReleaseInstance (pInstance);
}


RTTIResult CCall_rtti_acquireinstance(RTTIHandle libraryHandle, RTTI_Base pInstance)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_AcquireInstance (pInstance);
}


RTTIResult CCall_rtti_injectcomponent(RTTIHandle libraryHandle, const char * pNameSpace, RTTI_pvoid pSymbolAddressMethod)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_InjectComponent (pNameSpace, pSymbolAddressMethod);
}


RTTIResult CCall_rtti_getsymbollookupmethod(RTTIHandle libraryHandle, RTTI_pvoid * pSymbolLookupMethod)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetSymbolLookupMethod (pSymbolLookupMethod);
}


RTTIResult CCall_rtti_createzoo(RTTIHandle libraryHandle, RTTI_Zoo * pInstance)
{
	if (libraryHandle == 0) 
		return RTTI_ERROR_INVALIDCAST;
	sRTTIDynamicWrapperTable * wrapperTable = (sRTTIDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_CreateZoo (pInstance);
}

*/
import "C"

import (
	"fmt"
	"unsafe"
	"runtime"
)

type ref = C.RTTIHandle

// Error constants for RTTI.
const RTTI_ERROR_NOTIMPLEMENTED = 1;
const RTTI_ERROR_INVALIDPARAM = 2;
const RTTI_ERROR_INVALIDCAST = 3;
const RTTI_ERROR_BUFFERTOOSMALL = 4;
const RTTI_ERROR_GENERICEXCEPTION = 5;
const RTTI_ERROR_COULDNOTLOADLIBRARY = 6;
const RTTI_ERROR_COULDNOTFINDLIBRARYEXPORT = 7;
const RTTI_ERROR_INCOMPATIBLEBINARYVERSION = 8;

// WrappedError is an error that wraps a RTTI error.
type WrappedError struct {
	Code uint32
	Message string
}

func (e *WrappedError) Error() string {
	return fmt.Sprintf("rtti: %s (%d)", e.Message, e.Code)
}

func errorMessage(errorcode uint32) string {
	switch (errorcode) {
	case RTTI_ERROR_NOTIMPLEMENTED:
		return "functionality not implemented";
	case RTTI_ERROR_INVALIDPARAM:
		return "an invalid parameter was passed";
	case RTTI_ERROR_INVALIDCAST:
		return "a type cast failed";
	case RTTI_ERROR_BUFFERTOOSMALL:
		return "a provided buffer is too small";
	case RTTI_ERROR_GENERICEXCEPTION:
		return "a generic exception occurred";
	case RTTI_ERROR_COULDNOTLOADLIBRARY:
		return "the library could not be loaded";
	case RTTI_ERROR_COULDNOTFINDLIBRARYEXPORT:
		return "a required exported symbol could not be found in the library";
	case RTTI_ERROR_INCOMPATIBLEBINARYVERSION:
		return "the version of the binary interface does not match the bindings interface";
	default:
		return "unknown";
	}
}

func makeError(errorcode uint32) error {
	return &WrappedError{errorcode, errorMessage(uint32(errorcode))}
}

// Wrapper represents the number wrapper
type Wrapper struct {
	_ [0]func() // uncomparable; to make == not compile
	LibraryHandle ref
}

// Base represents a RTTI class.
type Base struct {
	_     		[0]func() // uncomparable; to make == not compile
	Ref   		ref       // identifies a C value, see ref type
	wrapperRef Wrapper
	gcPtr 		*ref      // used to trigger the finalizer when the Value is not referenced any more
}

// NewBase creates a new Base.
// The wrapped C pointer will be freed when the Go pointer is finalized,
// but one can release it manually calling Release.
func (wrapper Wrapper) NewBase(r ref) Base {
	gcPtr := new(ref)
	*gcPtr = r
	runtime.SetFinalizer(gcPtr, wrapper.releaseC)
	return Base{Ref: r, gcPtr: gcPtr, wrapperRef: wrapper}
}

// Release releases the C pointer.
func (inst Base) Release() error {
	err := inst.wrapperRef.ReleaseInstance(inst)
	*inst.gcPtr = nil
	return err
}

// Equal reports whether inst and w refer to the same C pointer.
func (inst Base) Equal(w Base) bool {
	return inst.Ref == w.Ref
}
// ClassTypeId get Class Type Id.
func (inst Base) ClassTypeId() (uint64, error) {
	var classTypeId C.uint64_t
	ret := C.CCall_rtti_base_classtypeid(inst.wrapperRef.LibraryHandle, inst.Ref, &classTypeId)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(classTypeId), nil
}


// Animal represents a RTTI class.
type Animal struct {
	Base
}

func (wrapper Wrapper) NewAnimal(r ref) Animal {
	return Animal{wrapper.NewBase(r)}
}

// Name get the name of the animal.
func (inst Animal) Name() (string, error) {
	var neededforresult C.uint32_t
	var filledinresult C.uint32_t
	ret := C.CCall_rtti_animal_name(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforresult, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizeresult := neededforresult
	bufferresult := make([]byte, bufferSizeresult)
	ret = C.CCall_rtti_animal_name(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizeresult, &filledinresult, (*C.char)(unsafe.Pointer(&bufferresult[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferresult[:(filledinresult-1)]), nil
}


// Mammal represents a RTTI class.
type Mammal struct {
	Animal
}

func (wrapper Wrapper) NewMammal(r ref) Mammal {
	return Mammal{wrapper.NewAnimal(r)}
}


// Reptile represents a RTTI class.
type Reptile struct {
	Animal
}

func (wrapper Wrapper) NewReptile(r ref) Reptile {
	return Reptile{wrapper.NewAnimal(r)}
}


// Giraffe represents a RTTI class.
type Giraffe struct {
	Mammal
}

func (wrapper Wrapper) NewGiraffe(r ref) Giraffe {
	return Giraffe{wrapper.NewMammal(r)}
}


// Tiger represents a RTTI class.
type Tiger struct {
	Mammal
}

func (wrapper Wrapper) NewTiger(r ref) Tiger {
	return Tiger{wrapper.NewMammal(r)}
}

// Roar roar like a tiger.
func (inst Tiger) Roar() error {
	ret := C.CCall_rtti_tiger_roar(inst.wrapperRef.LibraryHandle, inst.Ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}


// Snake represents a RTTI class.
type Snake struct {
	Reptile
}

func (wrapper Wrapper) NewSnake(r ref) Snake {
	return Snake{wrapper.NewReptile(r)}
}


// Turtle represents a RTTI class.
type Turtle struct {
	Reptile
}

func (wrapper Wrapper) NewTurtle(r ref) Turtle {
	return Turtle{wrapper.NewReptile(r)}
}


// AnimalIterator represents a RTTI class.
type AnimalIterator struct {
	Base
}

func (wrapper Wrapper) NewAnimalIterator(r ref) AnimalIterator {
	return AnimalIterator{wrapper.NewBase(r)}
}

// GetNextAnimal return next animal.
func (inst AnimalIterator) GetNextAnimal() (*Animal, error) {
	var animal ref
	ret := C.CCall_rtti_animaliterator_getnextanimal(inst.wrapperRef.LibraryHandle, inst.Ref, &animal)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	var _animalPtr *Animal
	if animal != nil {
		_animalPtrVal := inst.wrapperRef.NewAnimal(animal)
		_animalPtr = &_animalPtrVal
	}
	return _animalPtr, nil
}


// Zoo represents a RTTI class.
type Zoo struct {
	Base
}

func (wrapper Wrapper) NewZoo(r ref) Zoo {
	return Zoo{wrapper.NewBase(r)}
}

// Iterator return an iterator over all zoo animals.
func (inst Zoo) Iterator() (AnimalIterator, error) {
	var iterator ref
	ret := C.CCall_rtti_zoo_iterator(inst.wrapperRef.LibraryHandle, inst.Ref, &iterator)
	if ret != 0 {
		return AnimalIterator{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewAnimalIterator(iterator), nil
}


// GetVersion retrieves the binary version of this library.
func (wrapper Wrapper) GetVersion() (uint32, uint32, uint32, error) {
	var major C.uint32_t
	var minor C.uint32_t
	var micro C.uint32_t
	ret := C.CCall_rtti_getversion(wrapper.LibraryHandle, &major, &minor, &micro)
	if ret != 0 {
		return 0, 0, 0, makeError(uint32(ret))
	}
	return uint32(major), uint32(minor), uint32(micro), nil
}

// GetLastError returns the last error recorded on this object.
func (wrapper Wrapper) GetLastError(instance Base) (string, bool, error) {
	var neededforerrorMessage C.uint32_t
	var filledinerrorMessage C.uint32_t
	var hasError C.bool
	ret := C.CCall_rtti_getlasterror(wrapper.LibraryHandle, instance.Ref, 0, &neededforerrorMessage, nil, &hasError)
	if ret != 0 {
		return "", false, makeError(uint32(ret))
	}
	bufferSizeerrorMessage := neededforerrorMessage
	buffererrorMessage := make([]byte, bufferSizeerrorMessage)
	ret = C.CCall_rtti_getlasterror(wrapper.LibraryHandle, instance.Ref, bufferSizeerrorMessage, &filledinerrorMessage, (*C.char)(unsafe.Pointer(&buffererrorMessage[0])), &hasError)
	if ret != 0 {
		return "", false, makeError(uint32(ret))
	}
	return string(buffererrorMessage[:(filledinerrorMessage-1)]), bool(hasError), nil
}

// ReleaseInstance releases shared ownership of an Instance.
func (wrapper Wrapper) ReleaseInstance(instance Base) error {
	ret := C.CCall_rtti_releaseinstance(wrapper.LibraryHandle, instance.Ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// AcquireInstance acquires shared ownership of an Instance.
func (wrapper Wrapper) AcquireInstance(instance Base) error {
	ret := C.CCall_rtti_acquireinstance(wrapper.LibraryHandle, instance.Ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// InjectComponent injects an imported component for usage within this component.
func (wrapper Wrapper) InjectComponent(nameSpace string, symbolAddressMethod uintptr) error {
	ret := C.CCall_rtti_injectcomponent(wrapper.LibraryHandle, (*C.char)(unsafe.Pointer(&[]byte(nameSpace)[0])), (C.RTTI_pvoid)(symbolAddressMethod))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetSymbolLookupMethod returns the address of the SymbolLookupMethod.
func (wrapper Wrapper) GetSymbolLookupMethod() (uintptr, error) {
	var symbolLookupMethod C.RTTI_pvoid
	ret := C.CCall_rtti_getsymbollookupmethod(wrapper.LibraryHandle, &symbolLookupMethod)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uintptr(symbolLookupMethod), nil
}

// CreateZoo create a new zoo with animals.
func (wrapper Wrapper) CreateZoo() (Zoo, error) {
	var instance ref
	ret := C.CCall_rtti_createzoo(wrapper.LibraryHandle, &instance)
	if ret != 0 {
		return Zoo{}, makeError(uint32(ret))
	}
	return wrapper.NewZoo(instance), nil
}

func (wrapper Wrapper) releaseC(r *ref) error {
	if r == nil || *r == nil {
		return nil
	}
	return wrapper.ReleaseInstance(Base{Ref: *r})
}

func (wrapper Wrapper) CheckBinaryVersion() error {
	var nBindingMajor uint32 = 1;
	var nBindingMinor uint32 = 0;
	nMajor, nMinor, _, err := wrapper.GetVersion()
	if err != nil {
		return err;
	}
	if (nMajor != nBindingMajor) || (nMinor < nBindingMinor) {
		return makeError(0)
	}
	return nil
}

func LoadLibrary (libraryPath string) (Wrapper, error) {
	var wrapper Wrapper;
	wrapper.LibraryHandle = C.loadRTTILibrary (C.CString (libraryPath));
	if (wrapper.LibraryHandle == nil) {
		return wrapper, makeError (RTTI_ERROR_COULDNOTLOADLIBRARY)
	}
	
	return wrapper, nil
	
}
