(*++

Copyright (C) 2021 ADSK

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Pascal export implementation file in order to allow easy
development of RTTI. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*)

{$MODE DELPHI}
unit rtti_exports;

interface

uses
	rtti_impl,
	rtti_types,
	rtti_interfaces,
	rtti_exception,
	Classes,
	sysutils;

(*************************************************************************************************************************
 Class export definition of Base 
**************************************************************************************************************************)

(**
* Get Class Type Id
*
* @param[in] pBase - Base instance.
* @param[out] pClassTypeId - Class type as a 64 bits integer
* @return error code or 0 (success)
*)
function rtti_base_classtypeid(pBase: TRTTIHandle; pClassTypeId: PQWord): TRTTIResult; cdecl;

(*************************************************************************************************************************
 Class export definition of Animal 
**************************************************************************************************************************)

(**
* Get the name of the animal
*
* @param[in] pAnimal - Animal instance.
* @param[in] nResultBufferSize - size of the buffer (including trailing 0)
* @param[out] pResultNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pResultBuffer -  buffer of , may be NULL
* @return error code or 0 (success)
*)
function rtti_animal_name(pAnimal: TRTTIHandle; nResultBufferSize: Cardinal; pResultNeededChars: PCardinal; pResultBuffer: PAnsiChar): TRTTIResult; cdecl;

(*************************************************************************************************************************
 Class export definition of Mammal 
**************************************************************************************************************************)

(*************************************************************************************************************************
 Class export definition of Reptile 
**************************************************************************************************************************)

(*************************************************************************************************************************
 Class export definition of Giraffe 
**************************************************************************************************************************)

(*************************************************************************************************************************
 Class export definition of Tiger 
**************************************************************************************************************************)

(**
* Roar like a tiger
*
* @param[in] pTiger - Tiger instance.
* @return error code or 0 (success)
*)
function rtti_tiger_roar(pTiger: TRTTIHandle): TRTTIResult; cdecl;

(*************************************************************************************************************************
 Class export definition of Snake 
**************************************************************************************************************************)

(*************************************************************************************************************************
 Class export definition of Turtle 
**************************************************************************************************************************)

(*************************************************************************************************************************
 Class export definition of AnimalIterator 
**************************************************************************************************************************)

(**
* Return next animal
*
* @param[in] pAnimalIterator - AnimalIterator instance.
* @param[out] pAnimal - 
* @return error code or 0 (success)
*)
function rtti_animaliterator_getnextanimal(pAnimalIterator: TRTTIHandle; pAnimal: PRTTIHandle): TRTTIResult; cdecl;

(*************************************************************************************************************************
 Class export definition of Zoo 
**************************************************************************************************************************)

(**
* Return an iterator over all zoo animals
*
* @param[in] pZoo - Zoo instance.
* @param[out] pIterator - 
* @return error code or 0 (success)
*)
function rtti_zoo_iterator(pZoo: TRTTIHandle; pIterator: PRTTIHandle): TRTTIResult; cdecl;

(*************************************************************************************************************************
 Global function export definition
**************************************************************************************************************************)

(**
* retrieves the binary version of this library.
*
* @param[out] pMajor - returns the major version of this library
* @param[out] pMinor - returns the minor version of this library
* @param[out] pMicro - returns the micro version of this library
* @return error code or 0 (success)
*)
function rtti_getversion(pMajor: PCardinal; pMinor: PCardinal; pMicro: PCardinal): TRTTIResult; cdecl;

(**
* Returns the last error recorded on this object
*
* @param[in] pInstance - Instance Handle
* @param[in] nErrorMessageBufferSize - size of the buffer (including trailing 0)
* @param[out] pErrorMessageNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pErrorMessageBuffer -  buffer of Message of the last error, may be NULL
* @param[out] pHasError - Is there a last error to query
* @return error code or 0 (success)
*)
function rtti_getlasterror(pInstance: TRTTIHandle; nErrorMessageBufferSize: Cardinal; pErrorMessageNeededChars: PCardinal; pErrorMessageBuffer: PAnsiChar; pHasError: PByte): TRTTIResult; cdecl;

(**
* Releases shared ownership of an Instance
*
* @param[in] pInstance - Instance Handle
* @return error code or 0 (success)
*)
function rtti_releaseinstance(pInstance: TRTTIHandle): TRTTIResult; cdecl;

(**
* Acquires shared ownership of an Instance
*
* @param[in] pInstance - Instance Handle
* @return error code or 0 (success)
*)
function rtti_acquireinstance(pInstance: TRTTIHandle): TRTTIResult; cdecl;

(**
* Injects an imported component for usage within this component
*
* @param[in] pNameSpace - NameSpace of the injected component
* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
* @return error code or 0 (success)
*)
function rtti_injectcomponent(pNameSpace: PAnsiChar; pSymbolAddressMethod: Pointer): TRTTIResult; cdecl;

(**
* Returns the address of the SymbolLookupMethod
*
* @param[out] pSymbolLookupMethod - Address of the SymbolAddressMethod
* @return error code or 0 (success)
*)
function rtti_getsymbollookupmethod(pSymbolLookupMethod: PPointer): TRTTIResult; cdecl;

(**
* Create a new zoo with animals
*
* @param[out] pInstance - 
* @return error code or 0 (success)
*)
function rtti_createzoo(pInstance: PRTTIHandle): TRTTIResult; cdecl;


(*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************)

function _rtti_getprocaddress_internal(pProcName: PAnsiChar; out ppProcAddress: Pointer): TRTTIResult cdecl;

implementation

function rtti_base_classtypeid(pBase: TRTTIHandle; pClassTypeId: PQWord): TRTTIResult; cdecl;
var
	ResultClassTypeId: QWord;
	ObjectBase: TObject;
	IntfBase: IRTTIBase;
begin
	try
		if not Assigned(pClassTypeId) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);
		if not Assigned(pBase) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		ObjectBase := TObject(pBase);
		if Supports(ObjectBase, IRTTIBase) then begin
			IntfBase := ObjectBase as IRTTIBase;
			ResultClassTypeId := IntfBase.ClassTypeId();

			pClassTypeId^ := ResultClassTypeId;
		end else
			raise ERTTIException.Create(RTTI_ERROR_INVALIDCAST);

		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := HandleRTTIException(ObjectBase , E);
		end;
		On E: Exception do begin
			Result := HandleStdException(ObjectBase , E);
		end
		else begin
			Result := HandleUnhandledException(ObjectBase);
		end;
	end;
end;

function rtti_animal_name(pAnimal: TRTTIHandle; nResultBufferSize: Cardinal; pResultNeededChars: PCardinal; pResultBuffer: PAnsiChar): TRTTIResult; cdecl;
var
	ResultResult: String;
	LenResult: Cardinal;
	ObjectAnimal: TObject;
	IntfAnimal: IRTTIAnimal;
begin
	try
		if ((not Assigned(pResultBuffer)) and (not Assigned(pResultNeededChars))) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);
		if not Assigned(pAnimal) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		ObjectAnimal := TObject(pAnimal);
		if Supports(ObjectAnimal, IRTTIAnimal) then begin
			IntfAnimal := ObjectAnimal as IRTTIAnimal;
			ResultResult := IntfAnimal.Name();

			LenResult := Length(ResultResult);
			if Assigned(pResultNeededChars) then
				pResultNeededChars^ := LenResult + 1;
			if Assigned(pResultBuffer) then begin
				if (LenResult >= nResultBufferSize) then
					raise ERTTIException.Create(RTTI_ERROR_BUFFERTOOSMALL);
				Move(PAnsiChar(ResultResult)^, pResultBuffer^, LenResult);
				pResultBuffer[LenResult] := Char(0);
			end;
		end else
			raise ERTTIException.Create(RTTI_ERROR_INVALIDCAST);

		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := HandleRTTIException(ObjectAnimal , E);
		end;
		On E: Exception do begin
			Result := HandleStdException(ObjectAnimal , E);
		end
		else begin
			Result := HandleUnhandledException(ObjectAnimal);
		end;
	end;
end;

function rtti_tiger_roar(pTiger: TRTTIHandle): TRTTIResult; cdecl;
var
	ObjectTiger: TObject;
	IntfTiger: IRTTITiger;
begin
	try
		if not Assigned(pTiger) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		ObjectTiger := TObject(pTiger);
		if Supports(ObjectTiger, IRTTITiger) then begin
			IntfTiger := ObjectTiger as IRTTITiger;
			IntfTiger.Roar();

		end else
			raise ERTTIException.Create(RTTI_ERROR_INVALIDCAST);

		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := HandleRTTIException(ObjectTiger , E);
		end;
		On E: Exception do begin
			Result := HandleStdException(ObjectTiger , E);
		end
		else begin
			Result := HandleUnhandledException(ObjectTiger);
		end;
	end;
end;

function rtti_animaliterator_getnextanimal(pAnimalIterator: TRTTIHandle; pAnimal: PRTTIHandle): TRTTIResult; cdecl;
var
	ResultAnimal: TObject;
	ObjectAnimalIterator: TObject;
	IntfAnimalIterator: IRTTIAnimalIterator;
begin
	try
		if not Assigned(pAnimal) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);
		if not Assigned(pAnimalIterator) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		ObjectAnimalIterator := TObject(pAnimalIterator);
		if Supports(ObjectAnimalIterator, IRTTIAnimalIterator) then begin
			IntfAnimalIterator := ObjectAnimalIterator as IRTTIAnimalIterator;
			ResultAnimal := IntfAnimalIterator.GetNextAnimal();

			pAnimal^ := ResultAnimal;
		end else
			raise ERTTIException.Create(RTTI_ERROR_INVALIDCAST);

		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := HandleRTTIException(ObjectAnimalIterator , E);
		end;
		On E: Exception do begin
			Result := HandleStdException(ObjectAnimalIterator , E);
		end
		else begin
			Result := HandleUnhandledException(ObjectAnimalIterator);
		end;
	end;
end;

function rtti_zoo_iterator(pZoo: TRTTIHandle; pIterator: PRTTIHandle): TRTTIResult; cdecl;
var
	ResultIterator: TObject;
	ObjectZoo: TObject;
	IntfZoo: IRTTIZoo;
begin
	try
		if not Assigned(pIterator) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);
		if not Assigned(pZoo) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		ObjectZoo := TObject(pZoo);
		if Supports(ObjectZoo, IRTTIZoo) then begin
			IntfZoo := ObjectZoo as IRTTIZoo;
			ResultIterator := IntfZoo.Iterator();

			pIterator^ := ResultIterator;
		end else
			raise ERTTIException.Create(RTTI_ERROR_INVALIDCAST);

		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := HandleRTTIException(ObjectZoo , E);
		end;
		On E: Exception do begin
			Result := HandleStdException(ObjectZoo , E);
		end
		else begin
			Result := HandleUnhandledException(ObjectZoo);
		end;
	end;
end;

function rtti_getversion(pMajor: PCardinal; pMinor: PCardinal; pMicro: PCardinal): TRTTIResult; cdecl;
begin
	try
		if (not Assigned(pMajor)) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		if (not Assigned(pMinor)) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		if (not Assigned(pMicro)) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);


		TRTTIWrapper.GetVersion(pMajor^, pMinor^, pMicro^);

		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := E.ErrorCode;
		end
		else begin
			Result := RTTI_ERROR_GENERICEXCEPTION;
		end
	end;
end;

function rtti_getlasterror(pInstance: TRTTIHandle; nErrorMessageBufferSize: Cardinal; pErrorMessageNeededChars: PCardinal; pErrorMessageBuffer: PAnsiChar; pHasError: PByte): TRTTIResult; cdecl;
var
	ObjectInstance: TObject;
	ResultErrorMessage: String;
	LenErrorMessage: Cardinal;
	ResultHasError: Boolean;
begin
	try
		ObjectInstance := TObject(pInstance);
		if (not Supports(ObjectInstance, IRTTIBase)) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDCAST);
		
		if ((not Assigned(pErrorMessageBuffer)) and (not Assigned(pErrorMessageNeededChars))) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);
		if not Assigned(pHasError) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		ResultHasError := TRTTIWrapper.GetLastError(ObjectInstance, ResultErrorMessage);

		LenErrorMessage := Length(ResultErrorMessage);
		if Assigned(pErrorMessageNeededChars) then
			pErrorMessageNeededChars^ := LenErrorMessage + 1;
		if Assigned(pErrorMessageBuffer) then begin
			if (LenErrorMessage >= nErrorMessageBufferSize) then
				raise ERTTIException.Create(RTTI_ERROR_BUFFERTOOSMALL);
			Move(PAnsiChar(ResultErrorMessage)^, pErrorMessageBuffer^, LenErrorMessage);
			pErrorMessageBuffer[LenErrorMessage] := Char(0);
		end;
		pHasError^ := Ord(ResultHasError);
		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := E.ErrorCode;
		end
		else begin
			Result := RTTI_ERROR_GENERICEXCEPTION;
		end
	end;
end;

function rtti_releaseinstance(pInstance: TRTTIHandle): TRTTIResult; cdecl;
var
	ObjectInstance: TObject;
begin
	try
		ObjectInstance := TObject(pInstance);
		if (not Supports(ObjectInstance, IRTTIBase)) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDCAST);
		

		TRTTIWrapper.ReleaseInstance(ObjectInstance);

		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := E.ErrorCode;
		end
		else begin
			Result := RTTI_ERROR_GENERICEXCEPTION;
		end
	end;
end;

function rtti_acquireinstance(pInstance: TRTTIHandle): TRTTIResult; cdecl;
var
	ObjectInstance: TObject;
begin
	try
		ObjectInstance := TObject(pInstance);
		if (not Supports(ObjectInstance, IRTTIBase)) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDCAST);
		

		TRTTIWrapper.AcquireInstance(ObjectInstance);

		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := E.ErrorCode;
		end
		else begin
			Result := RTTI_ERROR_GENERICEXCEPTION;
		end
	end;
end;

function rtti_injectcomponent(pNameSpace: PAnsiChar; pSymbolAddressMethod: Pointer): TRTTIResult; cdecl;
var
	ANameSpaceFound: boolean;
begin
	try
		if (not Assigned(pNameSpace)) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		if not ANameSpaceFound then
			raise ERTTIException.Create(RTTI_ERROR_COULDNOTLOADLIBRARY);
		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := E.ErrorCode;
		end
		else begin
			Result := RTTI_ERROR_GENERICEXCEPTION;
		end
	end;
end;

function rtti_getsymbollookupmethod(pSymbolLookupMethod: PPointer): TRTTIResult; cdecl;
begin
	try
		if not Assigned(pSymbolLookupMethod) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		pSymbolLookupMethod^ := @_rtti_getprocaddress_internal;
		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := E.ErrorCode;
		end
		else begin
			Result := RTTI_ERROR_GENERICEXCEPTION;
		end
	end;
end;

function rtti_createzoo(pInstance: PRTTIHandle): TRTTIResult; cdecl;
var
	ResultInstance: TObject;
begin
	try
		if not Assigned(pInstance) then
			raise ERTTIException.Create(RTTI_ERROR_INVALIDPARAM);

		ResultInstance := TRTTIWrapper.CreateZoo();

		pInstance^ := ResultInstance;
		Result := RTTI_SUCCESS;
	except
		On E: ERTTIException do begin
			Result := E.ErrorCode;
		end
		else begin
			Result := RTTI_ERROR_GENERICEXCEPTION;
		end
	end;
end;



(*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************)

function _rtti_getprocaddress_internal(pProcName: PAnsiChar; out ppProcAddress: Pointer): TRTTIResult cdecl;

begin
	result := RTTI_SUCCESS;
	ppProcAddress := nil;
	
	if (pProcName = 'rtti_base_classtypeid') then
		ppProcAddress := @rtti_base_classtypeid
	else if (pProcName = 'rtti_animal_name') then
		ppProcAddress := @rtti_animal_name
	else if (pProcName = 'rtti_tiger_roar') then
		ppProcAddress := @rtti_tiger_roar
	else if (pProcName = 'rtti_animaliterator_getnextanimal') then
		ppProcAddress := @rtti_animaliterator_getnextanimal
	else if (pProcName = 'rtti_zoo_iterator') then
		ppProcAddress := @rtti_zoo_iterator
	else if (pProcName = 'rtti_getversion') then
		ppProcAddress := @rtti_getversion
	else if (pProcName = 'rtti_getlasterror') then
		ppProcAddress := @rtti_getlasterror
	else if (pProcName = 'rtti_releaseinstance') then
		ppProcAddress := @rtti_releaseinstance
	else if (pProcName = 'rtti_acquireinstance') then
		ppProcAddress := @rtti_acquireinstance
	else if (pProcName = 'rtti_injectcomponent') then
		ppProcAddress := @rtti_injectcomponent
	else if (pProcName = 'rtti_getsymbollookupmethod') then
		ppProcAddress := @rtti_getsymbollookupmethod
	else if (pProcName = 'rtti_createzoo') then
		ppProcAddress := @rtti_createzoo
	else
		result := RTTI_ERROR_COULDNOTFINDLIBRARYEXPORT;
end;

end.

