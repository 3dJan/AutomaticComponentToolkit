/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildimplementationjs.go
// functions to generate C++ interface classes, implementation stubs and wrapper code that maps to
// the C-header.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"errors"
	"fmt"
	"log"
	"path"
	"strings"
)

// BuildImplementationJS builds C++ interface classes, implementation stubs and wrapper code that maps to the C-header
func BuildImplementationJS(component ComponentDefinition, outputFolder string, stubOutputFolder string, projectOutputFolder string, implementation ComponentDefinitionImplementation, suppressStub bool, suppressInterfaces bool) error {

	doJournal := len (component.Global.JournalMethod) > 0;
	
	NameSpace := component.NameSpace;
	LibraryName := component.LibraryName;
	BaseName := component.BaseName;
	ImplementationSubNameSpace := "Impl"

	log.Printf("Creating JavaScript Implementation")

	indentString := getIndentationString(implementation.Indentation)
	stubIdentifier := ""
	if len(implementation.StubIdentifier) > 0 {
		stubIdentifier = "_" + strings.ToLower(implementation.StubIdentifier)
	}

	if (!suppressInterfaces) {

		IntfExceptionHeaderName := path.Join(outputFolder, BaseName+"_interfaceexception.hpp");
		log.Printf("Creating \"%s\"", IntfExceptionHeaderName)
		hInternalExceptionHeaderFile, err :=  CreateLanguageFile (IntfExceptionHeaderName, indentString)
		if err != nil {
			return err
		}
		hInternalExceptionHeaderFile.WriteCLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated C++ Header file with the basic internal\n exception type in order to allow an easy use of %s", LibraryName),
			true)

		IntfExceptionImplName := path.Join(outputFolder, BaseName+"_interfaceexception.cpp");
		log.Printf("Creating \"%s\"", IntfExceptionImplName)
		hInternalExceptionImplFile, err :=  CreateLanguageFile (IntfExceptionImplName, indentString)
		if err != nil {
			return err
		}
		hInternalExceptionImplFile.WriteCLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated C++ Implementation file with the basic internal\n exception type in order to allow an easy use of %s", LibraryName),
			true)

		err = buildCPPInternalException(hInternalExceptionHeaderFile, hInternalExceptionImplFile, NameSpace, BaseName )
		if err != nil {
			return err
		}

		IntfHeaderName := path.Join(outputFolder, BaseName+"_interfaces.hpp");
		log.Printf("Creating \"%s\"", IntfHeaderName)
		interfaceshppfile, err := CreateLanguageFile (IntfHeaderName, indentString)
		if err != nil {
			return err
		}
		interfaceshppfile.WriteCLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated C++ header file in order to allow easy\ndevelopment of %s. The implementer of %s needs to\nderive concrete classes from the abstract classes in this header.", LibraryName, LibraryName),
			true)
		err = buildCPPInterfaces(component, interfaceshppfile, ImplementationSubNameSpace, implementation.ClassIdentifier)
		if err != nil {
			return err
		}

		IntfWrapperImplName := path.Join(outputFolder, BaseName+"_interfacewrapper.cpp");
		log.Printf("Creating \"%s\"", IntfWrapperImplName)
		cppWrapperfile, err := CreateLanguageFile(IntfWrapperImplName, indentString)
		if err != nil {
			return err
		}
		cppWrapperfile.WriteCLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated C++ implementation file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", LibraryName),
			true)
		err = buildCPPInterfaceWrapper(component, cppWrapperfile, NameSpace, ImplementationSubNameSpace, implementation.ClassIdentifier, BaseName, doJournal)
		if err != nil {
			return err
		}

		if (doJournal) {
			IntfJournalHeaderName := path.Join(outputFolder, strings.ToLower(BaseName)+"_interfacejournal.hpp");	
			log.Printf("Creating \"%s\"", IntfJournalHeaderName)
			interfacejournalhppfile, err := CreateLanguageFile (IntfJournalHeaderName, indentString)
			if err != nil {
				return err
			}
			interfacejournalhppfile.WriteCLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated C++ header file in order to allow easy\ndevelopment of %s. It provides an automatic Journaling mechanism for the library implementation.", LibraryName),
				true)
			
			IntfJournalImplName := path.Join(outputFolder, strings.ToLower(BaseName)+"_interfacejournal.cpp");
			log.Printf("Creating \"%s\"", IntfJournalImplName)
			interfacejournalcppfile, err := CreateLanguageFile(IntfJournalImplName, indentString)
			if err != nil {
				return err
			}
			interfacejournalcppfile.WriteCLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated C++ implementation file in order to allow easy\ndevelopment of %s. It provides an automatic Journaling mechanism for the library implementation.", LibraryName),
				true)
			
			err = buildJournalingCPP(component, interfacejournalhppfile, interfacejournalcppfile)
			if err != nil {
				return err
			}
		}
	
	}
	
	
	//if (!suppressStub) {
		err := buildJSTypesFiles (component, NameSpace, ImplementationSubNameSpace, implementation.ClassIdentifier, BaseName, stubOutputFolder, indentString, stubIdentifier);
		if err != nil {
			return err
		}
	
		for _, subComponent := range(component.ImportedComponentDefinitions) {
		
			for i := 0; i < len(subComponent.Classes); i++ {
				class := subComponent.Classes[i]
				err := buildJSInjectionClass (component, subComponent, class, NameSpace, ImplementationSubNameSpace, implementation.ClassIdentifier, BaseName, stubOutputFolder, indentString, stubIdentifier);
				if err != nil {
					return err
				}	
			}
			
		}
	
	//}

	return nil
}

func buildJSTypesFiles(component ComponentDefinition, NameSpace string, NameSpaceImplementation string, ClassIdentifier string, BaseName string, outputFolder string, indentString string, stubIdentifier string) error {

		TypesDefinitionFileName := path.Join(outputFolder, BaseName + stubIdentifier + "_v8types.hpp");
		ClassDefinitionFileName := path.Join(outputFolder, BaseName + stubIdentifier + "_v8classes.hpp");

		log.Printf("Creating \"%s\"", TypesDefinitionFileName)
		typesdefinitionw, err := CreateLanguageFile(TypesDefinitionFileName, indentString)
		if err != nil {
			return err
		}
		typesdefinitionw.WriteCLicenseHeader(component,
			"JavaScript injection type definitions", false);
		
		log.Printf("Creating \"%s\"", ClassDefinitionFileName)
		classdefinitionw, err := CreateLanguageFile(ClassDefinitionFileName, indentString)
		if err != nil {
			return err
		}
		classdefinitionw.WriteCLicenseHeader(component,
			"JavaScript injection class definitions", false);			

		typesdefinitionw.Writeln("")
		typesdefinitionw.Writeln("#ifndef __%s_V8TYPES", strings.ToUpper(NameSpace))
		typesdefinitionw.Writeln("#define __%s_V8TYPES", strings.ToUpper(NameSpace))
		typesdefinitionw.Writeln("")
		typesdefinitionw.Writeln("#include <stdint.h>")
		typesdefinitionw.Writeln("")
		
		typeEnumID := 1;
		
		typesdefinitionw.Writeln("namespace v8%s {", NameSpace );
		typesdefinitionw.Writeln("  namespace %s {", NameSpaceImplementation );
		typesdefinitionw.Writeln("")
		typesdefinitionw.Writeln("    enum class eInjectionClassType {")		
		typesdefinitionw.Writeln("      e_Injection_Invalid = 0," )
		for _, subComponent := range(component.ImportedComponentDefinitions) {
		
			for i := 0; i < len(subComponent.Classes); i++ {
				class := subComponent.Classes[i]
				typesdefinitionw.Writeln("      e_v8%s_%s = %d,", subComponent.NameSpace, class.ClassName, typeEnumID);
				typeEnumID = typeEnumID + 1;
			}
		
			
		}
		typesdefinitionw.Writeln("      e_Injection_enumMax" )		
		typesdefinitionw.Writeln("    };")
		typesdefinitionw.Writeln("")
		typesdefinitionw.Writeln("  }")
		typesdefinitionw.Writeln("}")
		typesdefinitionw.Writeln("")
		typesdefinitionw.Writeln("#endif // __%s_V8TYPES", strings.ToUpper(NameSpace))
		typesdefinitionw.Writeln("")
		
		
		

		classdefinitionw.Writeln("")
		classdefinitionw.Writeln("#ifndef __%s_V8CLASSES", strings.ToUpper(NameSpace))
		classdefinitionw.Writeln("#define __%s_V8CLASSES", strings.ToUpper(NameSpace))
		classdefinitionw.Writeln("")
		for _, subComponent := range(component.ImportedComponentDefinitions) {
		
			for i := 0; i < len(subComponent.Classes); i++ {
				class := subComponent.Classes[i]
				classdefinitionw.Writeln("#include \"%s_v8_%s_%s.hpp\"", component.BaseName + stubIdentifier, subComponent.BaseName, strings.ToLower(class.ClassName))
			}		
			
		}
		classdefinitionw.Writeln("")

		classdefinitionw.Writeln("namespace v8%s {", NameSpace );
		classdefinitionw.Writeln("  namespace %s {", NameSpaceImplementation );
		classdefinitionw.Writeln("")
		classdefinitionw.Writeln("    _inline void registerInjectionClasses (std::shared_ptr<Cv8objectCreator> pObjectCreator, v8::Local<v8::Object> pTarget)", )
		classdefinitionw.Writeln("    {")
		for _, subComponent := range(component.ImportedComponentDefinitions) {
		
			for i := 0; i < len(subComponent.Classes); i++ {
				class := subComponent.Classes[i]
				classdefinitionw.Writeln("      v8%s::Cv8%s%s::internalV8Register(pObjectCreator, pTarget);", subComponent.NameSpace, ClassIdentifier, class.ClassName);
			}		
			
		}
		classdefinitionw.Writeln("    }")
		classdefinitionw.Writeln("")
		
		
		classdefinitionw.AddIndentationLevel(2);
		for _, subComponent := range(component.ImportedComponentDefinitions) {
			writeMapClassIdtoInjectionClassTypeFunction(classdefinitionw, subComponent, subComponent.NameSpace)
			classdefinitionw.Writeln("")
		}
		classdefinitionw.AddIndentationLevel(-2);

		classdefinitionw.Writeln("  }")
		classdefinitionw.Writeln("}")
		classdefinitionw.Writeln("")
		classdefinitionw.Writeln("#endif // __%s_V8CLASSES", strings.ToUpper(NameSpace))
		classdefinitionw.Writeln("")
		

	return nil
}



func buildJSInjectionClass(component ComponentDefinition, subComponent ComponentDefinition, class ComponentDefinitionClass, NameSpace string, NameSpaceImplementation string, ClassIdentifier string, BaseName string, outputFolder string, indentString string, stubIdentifier string) error {
	baseFileName := fmt.Sprintf ("%s_v8_%s_%s", component.BaseName + stubIdentifier, subComponent.BaseName, strings.ToLower(class.ClassName));
	HeaderFileName := path.Join(outputFolder, baseFileName + ".hpp");
	CppFileName := path.Join(outputFolder, baseFileName + ".cpp");

		log.Printf("Creating \"%s\"", HeaderFileName)
		headerw, err := CreateLanguageFile(HeaderFileName, indentString)
		if err != nil {
			return err
		}
		
		headerw.WriteCLicenseHeader(component,
			"JavaScript definition for injection class " + subComponent.NameSpace + "::" + class.ClassName, false);
	
		log.Printf("Creating \"%s\"", CppFileName)
		cppw, err := CreateLanguageFile(CppFileName, indentString)
		if err != nil {
			return err
		}	
		cppw.WriteCLicenseHeader(component,
			"JavaScript implementation for injection class " + subComponent.NameSpace + "::" + class.ClassName, false); 
		
		
		headerw.Writeln("")
		headerw.Writeln("")
		headerw.Writeln("#ifndef __%s_V8_%s_%s", strings.ToUpper(NameSpace), strings.ToUpper(subComponent.NameSpace), strings.ToUpper(class.ClassName))
		headerw.Writeln("#define __%s_V8_%s_%s", strings.ToUpper(NameSpace), strings.ToUpper(subComponent.NameSpace), strings.ToUpper(class.ClassName))
		headerw.Writeln("")
		headerw.Writeln ("#include \"%s_v8objectcreator.hpp\"", component.BaseName);
		headerw.Writeln ("#include \"%s_v8objectwrapper.hpp\"", component.BaseName);
		headerw.Writeln("")

		headerw.Writeln("namespace v8%s {", NameSpace );
		headerw.Writeln("  namespace %s {", NameSpaceImplementation );
		headerw.Writeln("    namespace v8%s {", subComponent.NameSpace );
		headerw.Writeln("")
		
		headerw.Writeln("       class Cv8%s : public Cv8objectWrapper", class.ClassName);
		headerw.Writeln("       {");
		headerw.Writeln("         public:");
		headerw.Writeln("")		
		headerw.Writeln("           /* constructors, destructor and operators */");
		headerw.Writeln("           Cv8%s();", class.ClassName);
		headerw.Writeln("           Cv8%s(v8::Local<v8::Object> localObject);", class.ClassName);
		headerw.Writeln("           Cv8%s(const Cv8%s& valueReference);", class.ClassName, class.ClassName);
		headerw.Writeln("           virtual ~Cv8%s();",  class.ClassName);
		headerw.Writeln("")			
		headerw.Writeln("           Cv8%s& operator=(const Cv8%s& valueReference);", class.ClassName, class.ClassName);
		headerw.Writeln("           static Cv8%s* Cast(Cv8objectWrapper* objectWrapper);",  class.ClassName);
		headerw.Writeln("");
		headerw.Writeln("           /* class helper methods */");
		headerw.Writeln("           static eInjectionClassType getClassType();");
		headerw.Writeln("");
		headerw.Writeln("           static %s::P%s getInstance(const v8::FunctionCallbackInfo<v8::Value>& args);", subComponent.NameSpace, class.ClassName);
		headerw.Writeln("");	
		headerw.Writeln("           /* V8 Registration commands */");
		headerw.Writeln("           static void internalV8Register(std::shared_ptr<Cv8objectCreator> pObjectCreator, v8::Local<v8::Object> target);");
		headerw.Writeln("           static void internalV8New(const v8::FunctionCallbackInfo<v8::Value>& args);");
		headerw.Writeln("");	
		headerw.Writeln("           /* V8 Method implementations */");
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			headerw.Writeln("           static void v8%s(const v8::FunctionCallbackInfo<v8::Value>& args);", method.MethodName);
			
		}

			//static void V8Data(const v8::FunctionCallbackInfo<v8::Value>& args);
		headerw.Writeln("");	
		headerw.Writeln("         };");

		headerw.Writeln("")
		headerw.Writeln("    }")
		headerw.Writeln("  }")
		headerw.Writeln("}")
		headerw.Writeln("")
		headerw.Writeln("#endif // __%s_V8_%s_%s", strings.ToUpper(NameSpace), strings.ToUpper(subComponent.NameSpace), strings.ToUpper(class.ClassName))
		headerw.Writeln("")

		cppw.Writeln ("");
		cppw.Writeln ("#include \"%s.hpp\"", baseFileName);
		cppw.Writeln ("");
		cppw.Writeln ("#include \"%s_v8utils.hpp\"", component.BaseName);
		cppw.Writeln ("#include \"%s_v8objectcreator.hpp\"", component.BaseName);
		cppw.Writeln ("#include \"%s%s_v8classes.hpp\"", component.BaseName, stubIdentifier);
		cppw.Writeln("");
		cppw.Writeln("");
		
		cppw.Writeln("using namespace v8%s::%s;", NameSpace, NameSpaceImplementation);
		cppw.Writeln("using namespace v8%s::%s::v8%s;", NameSpace, NameSpaceImplementation, subComponent.NameSpace );
		cppw.Writeln("")
				
		cppw.Writeln("Cv8%s::Cv8%s()", class.ClassName, class.ClassName);
		cppw.Writeln("  : Cv8objectWrapper(getClassType())");
		cppw.Writeln("{");
		cppw.Writeln("}");
		cppw.Writeln("");

		cppw.Writeln("Cv8%s::Cv8%s(v8::Local<v8::Object> localObject)", class.ClassName, class.ClassName);
		cppw.Writeln("  : Cv8objectWrapper(getClassType())");
		cppw.Writeln("{");
		cppw.Writeln("  Wrap(localObject);");
		cppw.Writeln("}");
		cppw.Writeln("");

		cppw.Writeln("Cv8%s::Cv8%s(const Cv8%s& valueReference)", class.ClassName, class.ClassName, class.ClassName);
		cppw.Writeln("  : Cv8objectWrapper(getClassType())");
		cppw.Writeln("{");
		cppw.Writeln("  setObjectInstances(valueReference.m_pObjectCreator, valueReference.m_pObjectInstance);");
		cppw.Writeln("}");
		cppw.Writeln("");


		cppw.Writeln("Cv8%s::~Cv8%s()", class.ClassName, class.ClassName);
		cppw.Writeln("{");
		cppw.Writeln("}");
		cppw.Writeln("");

		cppw.Writeln("eInjectionClassType Cv8%s::getClassType()", class.ClassName);
		cppw.Writeln("{");
		cppw.Writeln("  return eInjectionClassType::e_v8%s_%s;", subComponent.NameSpace, class.ClassName);
		cppw.Writeln("}");
		cppw.Writeln("");

		cppw.Writeln("Cv8%s* Cv8%s::Cast(Cv8objectWrapper* objectWrapper)", class.ClassName, class.ClassName);
		cppw.Writeln("{");
		cppw.Writeln("  if (objectWrapper != nullptr) {");
		cppw.Writeln("    if (objectWrapper->get_type() == getClassType())");
		cppw.Writeln("      return static_cast<Cv8%s*>(objectWrapper);", class.ClassName);
		cppw.Writeln("  }");
		cppw.Writeln("  return nullptr;");
		cppw.Writeln("}");
		cppw.Writeln("");
		
		cppw.Writeln("%s::P%s Cv8%s::getInstance(const v8::FunctionCallbackInfo<v8::Value>& args)", subComponent.NameSpace, class.ClassName, class.ClassName); 
		cppw.Writeln("{");
		cppw.Writeln("  auto objectWrapper = Cv8%s::Unwrap<Cv8%s>(args.Holder());", class.ClassName, class.ClassName);
		cppw.Writeln("  if (objectWrapper == nullptr)");
		cppw.Writeln("    throw std::runtime_error (\"could not get %s instance wrapper.\");", class.ClassName);
		cppw.Writeln("");
		cppw.Writeln("  auto pInstance = objectWrapper->m_pObjectInstance;");
		cppw.Writeln("  if (pInstance.get () == nullptr)");
		cppw.Writeln("    throw std::runtime_error (\"could not get %s instance.\");", class.ClassName);
		cppw.Writeln("");
		cppw.Writeln("  auto pCastInstance = std::dynamic_pointer_cast<%s::C%s> (pInstance);", subComponent.NameSpace, class.ClassName);
		cppw.Writeln("  if (pCastInstance.get () == nullptr)");
		cppw.Writeln("    throw std::runtime_error (\"invalid %s instance type.\");", class.ClassName);
		cppw.Writeln("");
		cppw.Writeln("  return pCastInstance;");
		cppw.Writeln("}");
		cppw.Writeln("");
	
		cppw.Writeln("Cv8%s& Cv8%s::operator=(const Cv8%s& valueReference)", class.ClassName, class.ClassName, class.ClassName);
		cppw.Writeln("{");
		cppw.Writeln("  if (this != &valueReference)");
		cppw.Writeln("  {");
		cppw.Writeln("    setObjectInstances(valueReference.m_pObjectCreator, valueReference.m_pObjectInstance);");
		cppw.Writeln("  }");
		cppw.Writeln("  return *this;");
		cppw.Writeln("}");
		cppw.Writeln("");
	
		cppw.Writeln("void Cv8%s::internalV8Register(std::shared_ptr<Cv8objectCreator> pObjectCreator, v8::Local<v8::Object> target)", class.ClassName);
		cppw.Writeln("{");
		cppw.Writeln("  v8::Isolate* isolate = v8::Isolate::GetCurrent();");
		cppw.Writeln("  if (isolate == nullptr)");
		cppw.Writeln("    return;");
		cppw.Writeln("");
		cppw.Writeln("  // Create class template");
		cppw.Writeln("  v8::HandleScope handle_scope(isolate);");
		cppw.Writeln("");
		cppw.Writeln("  v8::Local<v8::FunctionTemplate> localClassTemplate = createClassTemplate (isolate, \"%s\", Cv8%s::internalV8New);", class.ClassName, class.ClassName);
		cppw.Writeln("");
		cppw.Writeln("  // Add functions to prototype object");		
		for i := 0; i < len(class.Methods); i++ {
			method := class.Methods[i]
						
			lowerCaseMethodName := strings.ToLower(method.MethodName[:1]) + method.MethodName[1:];
			
			cppw.Writeln("  Cv8toolsUtils::Set_proto_method(localClassTemplate, \"%s\", Cv8%s::v8%s);", method.MethodName, class.ClassName, method.MethodName);
			cppw.Writeln("  Cv8toolsUtils::Set_proto_method(localClassTemplate, \"%s\", Cv8%s::v8%s);", lowerCaseMethodName, class.ClassName, method.MethodName);
		}
		cppw.Writeln("");
		cppw.Writeln("  pObjectCreator->setTemplate(getClassType(), localClassTemplate);");
		cppw.Writeln("}");
		cppw.Writeln("");

		cppw.Writeln("void Cv8%s::internalV8New(const v8::FunctionCallbackInfo<v8::Value>& args)", class.ClassName);
		cppw.Writeln("{");
		cppw.Writeln("  if (!args.IsConstructCall())");
		cppw.Writeln("  {");
		cppw.Writeln("    Cv8toolsUtils::Throw_error(\"Expected constructor call type\");");
		cppw.Writeln("    return;");
		cppw.Writeln("  }");
		cppw.Writeln("  new Cv8%s(args.This());", class.ClassName);
		cppw.Writeln("}");
		cppw.Writeln("");
		cppw.Writeln("");
	
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
		
			argCount := 0;
			argString := "";
			for k := 0; k < len(method.Params); k++ {
				if (method.Params[k].ParamPass != "return") {
					if (argCount != 0) {
						argString = argString + ", ";						
					}
					
					argString = argString + method.Params[k].ParamName;
				
					argCount = argCount + 1;
				}
			}
			
		
			cppw.Writeln("void Cv8%s::v8%s(const v8::FunctionCallbackInfo<v8::Value>& args)", class.ClassName, method.MethodName);
			cppw.Writeln("{");
			cppw.Writeln("  v8::Isolate* isolate = v8::Isolate::GetCurrent();");
			cppw.Writeln("");
			cppw.Writeln("  try {");
			cppw.Writeln("    checkArgumentParameters(args, %d, \"%s.%s (%s)\");", argCount, class.ClassName, method.MethodName, argString);
			cppw.Writeln("");
			cppw.Writeln("    auto instancePtr = getInstance(args);");
			cppw.Writeln("");
			cppw.Writeln("    auto v8instance = Cv8%s::Unwrap<Cv8%s>(args.Holder());", class.ClassName, class.ClassName);
			cppw.Writeln("    if (v8instance == nullptr)");
			cppw.Writeln("      throw std::runtime_error(\"could not get %s instance.\");", class.ClassName);
			cppw.Writeln("");
			cppw.Writeln("    auto objectCreator = v8instance->getObjectCreator();");
			cppw.Writeln("    if (objectCreator == nullptr)");
			cppw.Writeln("      throw std::runtime_error(\"invalid object creator.\");");
			cppw.Writeln("");
			
			resultString := "";
			argumentString := "";
			returnValueCall := "";
			returnValueParameter := "";
			
			baseClassName := "P" + component.Global.BaseClassName;
			
			for k := 0; k < len(method.Params); k++ {
				param := method.Params[k];
				
					cppParamType := "";
					argumentMethodCallType := "";
					argumentDefault := "";
					cppReturnValueCast := "";
				
					switch (param.ParamType) {
						case "uint8":
							cppParamType = param.ParamType + "_t";
							argumentMethodCallType = "Uint8";
							argumentDefault = "0";
						case "uint16":
							cppParamType = param.ParamType + "_t";
							argumentMethodCallType = "Uint16";
							argumentDefault = "0";
						case "uint32":
							cppParamType = param.ParamType + "_t";
							argumentMethodCallType = "Uint32";
							argumentDefault = "0";
						case "uint64":
							cppParamType = param.ParamType + "_t";
							argumentMethodCallType = "Uint64";
							argumentDefault = "0";
						case "int8":
							cppParamType = param.ParamType + "_t";
							argumentMethodCallType = "Int8";
							argumentDefault = "0";
						case "int16":
							cppParamType = param.ParamType + "_t";
							argumentMethodCallType = "Int16";
							argumentDefault = "0";
						case "int32":
							cppParamType = param.ParamType + "_t";
							argumentMethodCallType = "Int32";
							argumentDefault = "0";
						case "int64":
							cppParamType = param.ParamType + "_t";
							argumentMethodCallType = "Int64";
							argumentDefault = "0";
						case "single":
							cppParamType = "float";
							argumentMethodCallType = "Float";
							argumentDefault = "0.0f";
						case "double":
							cppParamType = "double";
							argumentMethodCallType = "Double";
							argumentDefault = "0.0";
						case "string":
							cppParamType = "std::string";
							argumentMethodCallType = "String";
							argumentDefault = "\"\"";
						case "bool":
							cppParamType = "bool";
							argumentMethodCallType = "Bool";
							argumentDefault = "false";
						case "pointer":
							cppParamType = "void *";
							argumentMethodCallType = "Pointer";
							argumentDefault = "nullptr";
						case "class", "optionalclass":
							cppParamType = subComponent.NameSpace + "::P" + param.ParamClass;
							argumentMethodCallType = "Object";
							argumentDefault = "nullptr";
						case "enum":
							cppParamType = subComponent.NameSpace + "::e" + param.ParamClass;
							argumentMethodCallType = "Int32";
							argumentDefault = "(" + subComponent.NameSpace + "::e" + param.ParamClass + ") 0";
							cppReturnValueCast = "(" + subComponent.NameSpace + "::e" + param.ParamClass + ")"
						default:
							return errors.New ("Invalid parameter type: " + param.ParamType);

/*						case "basicarray":
						case "structarray":
						case "struct":
						case "functiontype": */
					}
					
					if (param.ParamPass == "in") {
						if (argumentString != "") {
							argumentString = argumentString + ", ";							
						}
						argumentString = argumentString + "param" + param.ParamName;
					
						if (param.ParamType == "class") {
							cppw.Writeln("    %s::%s object%s = v8instance->get%sArgument (isolate, args, %d);", subComponent.NameSpace, baseClassName, param.ParamName, argumentMethodCallType, k);
							cppw.Writeln("    %s param%s = std::dynamic_pointer_cast<%s::C%s> (object%s);", cppParamType, param.ParamName, subComponent.NameSpace, param.ParamClass, param.ParamName);
						} else if (param.ParamType == "optionalclass") {
							cppw.Writeln("    %s::%s object%s = v8instance->get%sArgument (isolate, args, %d);", subComponent.NameSpace, baseClassName, param.ParamName, argumentMethodCallType, k);
							cppw.Writeln("    %s param%s = std::dynamic_pointer_cast<%s::C%s> (object%s);", cppParamType, param.ParamName, subComponent.NameSpace, param.ParamClass, param.ParamName);
						} else {
							cppw.Writeln("    %s param%s = %sv8instance->get%sArgument (isolate, args, %d);", cppParamType, param.ParamName, cppReturnValueCast, argumentMethodCallType, k);
						}
					}
					
					if (param.ParamPass == "out") {
						if (argumentString != "") {
							argumentString = argumentString + ", ";							
						}
						argumentString = argumentString + "param" + param.ParamName;
						
						cppw.Writeln("    %s param%s = %s;", cppParamType, param.ParamName, argumentDefault);
					}

					if (param.ParamPass == "return") {
						cppw.Writeln("    %s param%s = %s;", cppParamType, param.ParamName, argumentDefault);						
						resultString = "param" + param.ParamName + " = ";
						returnValueCall = "set" + argumentMethodCallType + "ReturnValue";
						
						if (param.ParamType == "class") {
							cppw.Writeln("    eInjectionClassType e%sClassType = %s_MapClassIdToInjectionClassType(param%s->%s());", param.ParamName, subComponent.NameSpace, param.ParamName, subComponent.Global.ClassTypeIdMethod);
							returnValueParameter = fmt.Sprintf ("createV8Instance(objectCreator, param%s, e%sClassType)", param.ParamName, param.ParamName);
						} else if (param.ParamType == "optionalclass") {
							cppw.Writeln("    eInjectionClassType e%sClassType = %s_MapClassIdToInjectionClassType(param%s->%s());", param.ParamName, subComponent.NameSpace, param.ParamName, subComponent.Global.ClassTypeIdMethod);
							returnValueParameter = fmt.Sprintf ("createV8Instance(objectCreator, param%s, e%sClassType)", param.ParamName, param.ParamName);
						} else if (param.ParamType == "enum") {
							returnValueParameter = "(uint32_t) param" + param.ParamName;
						} else {
							returnValueParameter = "param" + param.ParamName;
						}
					}
				
			}
				
			cppw.Writeln("    %sinstancePtr->%s (%s);", resultString, method.MethodName, argumentString);
			if (returnValueCall != "") {
				cppw.Writeln("    %s (isolate, args, %s);", returnValueCall, returnValueParameter);
			}
			cppw.Writeln("    ");
			cppw.Writeln("");
						
			cppw.Writeln("  }");
			cppw.Writeln("  catch (std::exception& E) {");
			cppw.Writeln("    throwV8Exception(isolate, E);");
			cppw.Writeln("  }");
			cppw.Writeln("}");
			cppw.Writeln("");
			
		}

			
		cppw.Writeln("")

	return nil;		
}


func writeMapClassIdtoInjectionClassTypeFunction(w LanguageWriter, component ComponentDefinition, NameSpace string) {
	w.Writeln("")
	w.Writeln("inline eInjectionClassType %s_MapClassIdToInjectionClassType(uint64_t nClassTypeId)", NameSpace)
	w.Writeln("{")
	w.Writeln("  switch(nClassTypeId) {")
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		classTypeId, chashHashString := class.classTypeId(NameSpace)
		w.Writeln("    case 0x%016XUL: return eInjectionClassType::e_v8%s_%s; break; // First 64 bits of SHA1 of a string: \"%s\"", classTypeId, NameSpace, class.ClassName, chashHashString)
	}
	w.Writeln("  }")

	w.Writeln("  return eInjectionClassType::e_Injection_Invalid;")
	w.Writeln("}")
}

