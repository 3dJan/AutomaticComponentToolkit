/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildbindingjava.go
// functions to generate dynamic Java-bindings of a library's API using Java Native Access (JNA).
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"log"
	"path"
	"strings"
	"bytes"
)

type javaParameter struct {
	ParamType             string
	ParamName             string
	ParamComment          string
	ParamConvention       string
	ParamTypeNoConvention string
}

// BuildBindingJavaDynamic builds dynamic Java-bindings of a library's API using Java Native Access (JNA).
func BuildBindingJavaDynamic(component ComponentDefinition, outputFolder string, outputFolderExample string, indent string) error {
	namespace := component.NameSpace
	libraryname := component.LibraryName
	
	JavaWrapperName := namespace + "Wrapper";
	JavaWrapperPath := path.Join(outputFolder, JavaWrapperName + ".java");
	log.Printf("Creating \"%s\"", JavaWrapperPath)
	JavaWrapperFile, err := CreateLanguageFile (JavaWrapperPath, indent)
	if err != nil {
		return err;
	}

	JavaWrapperFile.WriteJavaLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
		true)
	
	err = buildJavaWrapper(component, JavaWrapperFile, indent)
	if err != nil {
		return err;
	}

	for i := 0; i < len(component.Structs); i++ {
		structinfo := component.Structs[i]
		JavaStructPath := path.Join(outputFolder, structinfo.Name + ".java");
		log.Printf("Creating \"%s\"", JavaStructPath)

		JavaStructFile, err := CreateLanguageFile (JavaStructPath, indent)
		if err != nil {
			return err;
		}

		JavaStructFile.WriteJavaLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
			true)
	
		err = buildJavaStruct(component, JavaStructFile, indent, structinfo)
		if err != nil {
			return err;
		}
	}

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		JavaClassPath := path.Join(outputFolder, class.ClassName + ".java");
		log.Printf("Creating \"%s\"", JavaClassPath)

		JavaClassFile, err := CreateLanguageFile (JavaClassPath, indent)
		if err != nil {
			return err;
		}

		JavaClassFile.WriteJavaLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
			true)
	
		err = buildJavaClass(component, JavaClassFile, indent, class)
		if err != nil {
			return err;
		}
	}

	return nil;
}

func buildJavaClass(component ComponentDefinition, w LanguageWriter, indent string, class ComponentDefinitionClass) error {
	NameSpace := component.NameSpace
	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.Library;")
	w.Writeln("import com.sun.jna.Memory;")
	w.Writeln("import com.sun.jna.Native;")
	w.Writeln("import com.sun.jna.Pointer;")
	w.Writeln("")
	w.Writeln("import java.nio.charset.StandardCharsets;");
	w.Writeln("import java.util.Arrays;")
	w.Writeln("import java.util.List;")
	w.Writeln("")
	if component.isBaseClass(class) {
		w.Writeln("public class %s {", class.ClassName)
		w.Writeln("")
		w.Writeln(indent + "protected Pointer mHandle;");
		w.Writeln("")
		w.Writeln(indent + "protected %sWrapper mWrapper;", component.NameSpace);
		w.Writeln("")
	} else {
		ParentClass := class.ParentClass
		if ParentClass == "" {
			ParentClass = component.Global.BaseClassName
		}
		w.Writeln("public class %s extends %s {", class.ClassName, ParentClass)
		w.Writeln("")		
	}

	w.Writeln(indent + "protected %s(%sWrapper wrapper, Pointer handle) {", class.ClassName, component.NameSpace);
	if component.isBaseClass(class) {
		w.Writeln(indent + indent + "mHandle = handle;");
		w.Writeln(indent + indent + "mWrapper = wrapper;");
	} else {
		w.Writeln(indent + indent + "super(wrapper, handle);");
	}
	w.Writeln(indent + "}");
	w.Writeln("")

	if component.isBaseClass(class) {
		w.Writeln(indent + "@Override")
		w.Writeln(indent + "protected void finalize() throws Throwable {")
		w.Writeln(indent + indent + "mWrapper.%s(this);", MakeFirstLowerCase(component.Global.ReleaseMethod))
		w.Writeln(indent + indent + "super.finalize();")
		w.Writeln(indent + "}")
		w.Writeln("")
	}

	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]

		err := writeJavaClassMethodImplementation(method, w, NameSpace, class.ClassName, indent, false)
		if err != nil {
			return err
		}
	}

	w.Writeln("")
	w.Writeln("}")
	w.Writeln("")
	return nil;
}

func writeJavaClassMethodImplementation(method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, indent string, isGlobal bool) error {

	parameters := ""
	returnType := "void"

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		ParamTypeName, err := getJavaParameterType(param.ParamType, NameSpace, param.ParamClass, param.ParamPass, false)
		if err != nil {
			return err
		}

		switch param.ParamPass {
		case "in":
			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + ParamTypeName + " " + MakeFirstLowerCase(param.ParamName)

		case "out":
			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + ParamTypeName + " " + MakeFirstLowerCase(param.ParamName)

		case "return":
			if returnType != "void" {
				return fmt.Errorf("duplicate return value \"%s\" for Pascal method \"%s\"", param.ParamName, method.MethodName)
			}
			returnType = ParamTypeName
		}
	}

	defineCommands := make([]string, 0)
	initCommands := make([]string, 0)
	resultCommands := make([]string, 0)
	postInitCommands := make([]string, 0)
	wrapperCallPrefix := ""
	wrapperInstanceName := ""

	doInitCall := false

	callFunctionName := ""
	callFunctionParameters := ""
	initCallParameters := ""
	errorInstanceHandle := ""
	returnStmt := ""

	if isGlobal {
		callFunctionName = fmt.Sprintf("mInterface.%s_%s", strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
		errorInstanceHandle = "null"
		wrapperInstanceName = "this"
	} else {
		callFunctionName = fmt.Sprintf("mInterface.%s_%s_%s", strings.ToLower(NameSpace), strings.ToLower(ClassName), strings.ToLower(method.MethodName))
		callFunctionParameters = "mHandle"
		errorInstanceHandle = "this"
		wrapperCallPrefix = "mWrapper."
		wrapperInstanceName = "mWrapper"
	}

	initCallParameters = callFunctionParameters

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		PlainParamTypeName, err := getPascalParameterType(param.ParamType, NameSpace, param.ParamClass, true, false)
		if err != nil {
			return err
		}

		if callFunctionParameters != "" {
			callFunctionParameters = callFunctionParameters + ", "
		}

		if initCallParameters != "" {
			initCallParameters = initCallParameters + ", "
		}

		switch param.ParamPass {
		case "in":

			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "bool", "double", "pointer", "struct":
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName)
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName)

			case "string":
				initCommands = append(initCommands, "byte[] bytes" + param.ParamName + " = " + MakeFirstLowerCase(param.ParamName) + ".getBytes(StandardCharsets.UTF_8);")
				initCommands = append(initCommands, "Memory buffer" + param.ParamName + " = new Memory(bytes" + param.ParamName + ".length + 1);")
				initCommands = append(initCommands, "buffer" + param.ParamName + ".write(0, bytes" + param.ParamName + ", 0, bytes" + param.ParamName + ".length);")
				initCommands = append(initCommands, "buffer" + param.ParamName + ".setByte(bytes" + param.ParamName + ".length, (byte)0);")
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

			case "enum":
				callFunctionParameters = callFunctionParameters + "convert" + param.ParamClass + "ToConst(A" + param.ParamName + ")"
				initCallParameters = initCallParameters + "convert" + param.ParamClass + "ToConst(A" + param.ParamName + ")"

			case "basicarray":
				basicPlainTypeName, err := getPascalParameterType(param.ParamClass, NameSpace, "", true, false)
				if err != nil {
					return err
				}

				defineCommands = append(defineCommands, "Ptr"+param.ParamName+": P"+basicPlainTypeName+";")
				defineCommands = append(defineCommands, "Len"+param.ParamName+": QWord;")
				initCommands = append(initCommands, fmt.Sprintf("Len%s := Length(A%s);", param.ParamName, param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("if Len%s > $FFFFFFFF then", param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("  raise E%sException.CreateCustomMessage(%s_ERROR_INVALIDPARAM, \"array has too many entries.\");", NameSpace, strings.ToUpper(NameSpace)))
				initCommands = append(initCommands, fmt.Sprintf("if Len%s > 0 then", param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("  Ptr%s := @A%s[0]", param.ParamName, param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("else"))
				initCommands = append(initCommands, fmt.Sprintf("  Ptr%s := nil;", param.ParamName))
				initCommands = append(initCommands, "")

				callFunctionParameters = callFunctionParameters + "QWord(Len" + param.ParamName + "), Ptr" + param.ParamName
				initCallParameters = initCallParameters + "QWord(Len" + param.ParamName + "), Ptr" + param.ParamName

			case "structarray":

				defineCommands = append(defineCommands, "Ptr"+param.ParamName+": P"+NameSpace+param.ParamClass+";")
				defineCommands = append(defineCommands, "Len"+param.ParamName+": QWord;")
				initCommands = append(initCommands, fmt.Sprintf("Len%s := Length(A%s);", param.ParamName, param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("if Len%s > $FFFFFFFF then", param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("  raise E%sException.CreateCustomMessage(%s_ERROR_INVALIDPARAM, \"array has too many entries.\");", NameSpace, strings.ToUpper(NameSpace)))
				initCommands = append(initCommands, fmt.Sprintf("if Len%s > 0 then", param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("  Ptr%s := @A%s[0]", param.ParamName, param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("else"))
				initCommands = append(initCommands, fmt.Sprintf("  Ptr%s := nil;", param.ParamName))
				initCommands = append(initCommands, "")

				callFunctionParameters = callFunctionParameters + "QWord(Len" + param.ParamName + "), Ptr" + param.ParamName
				initCallParameters = initCallParameters + "QWord(Len" + param.ParamName + "), Ptr" + param.ParamName

			case "functiontype":
				initCommands = append(initCommands, fmt.Sprintf("if (%s == null) {", param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("  throw new %sException(%s_ERROR_INVALIDPARAM, \"%s is a null value.\");", NameSpace, strings.ToUpper(NameSpace), param.ParamName))
				initCommands = append(initCommands, fmt.Sprintf("}"))
				callFunctionParameters = callFunctionParameters + "A" + param.ParamName
				initCallParameters = initCallParameters + "A" + param.ParamName

			case "class", "optionalclass":
				defineCommands = append(defineCommands, "Pointer " + MakeFirstLowerCase(param.ParamName) + "Handle = null;")
				initCommands = append(initCommands, fmt.Sprintf("if (%s != null) {", MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, indent + MakeFirstLowerCase(param.ParamName) + "Handle = " + MakeFirstLowerCase(param.ParamName) + ".mHandle;")
				if (param.ParamType == "optionalclass") {

				} else {
					initCommands = append(initCommands, fmt.Sprintf("} else {"))
					initCommands = append(initCommands, indent + fmt.Sprintf("throw new %sException(%s_ERROR_INVALIDPARAM, \"%s is a null value.\");", NameSpace, strings.ToUpper(NameSpace), param.ParamName))
				}
				initCommands = append(initCommands, fmt.Sprintf("}"))
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName) + "Handle"
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName) + "Handle"

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)
			}

		case "out":

			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double", "pointer":
				if (param.ParamType == "uint8" || param.ParamType == "int8") {
					initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(1);")
				} else if (param.ParamType == "uint16" || param.ParamType == "int16") {
					initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(2);")
				} else if (param.ParamType == "uint32" || param.ParamType == "int32" || param.ParamType == "single") {
					initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(4);")
				} else if (param.ParamType == "uint64" || param.ParamType == "int64" || param.ParamType == "double" || param.ParamType == "pointer") {
					initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(8);")
				}
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName
				if (param.ParamType == "uint8") {
					resultCommands = append(resultCommands, fmt.Sprintf("%s.value = buffer%s.getChar(0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				} else if (param.ParamType == "int8") {
					resultCommands = append(resultCommands, fmt.Sprintf("%s.value = buffer%s.getByte(0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				} else if (param.ParamType == "uint16" || param.ParamType == "int16") {
					resultCommands = append(resultCommands, fmt.Sprintf("%s.value = buffer%s.getShort(0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				} else if (param.ParamType == "uint32" || param.ParamType == "int32") {
					resultCommands = append(resultCommands, fmt.Sprintf("%s.value = buffer%s.getInt(0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				} else if (param.ParamType == "uint64" || param.ParamType == "int64") {
					resultCommands = append(resultCommands, fmt.Sprintf("%s.value = buffer%s.getLong(0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				} else if (param.ParamType == "single") {
					resultCommands = append(resultCommands, fmt.Sprintf("%s.value = buffer%s.getFloat(0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				} else if (param.ParamType == "double") {
					resultCommands = append(resultCommands, fmt.Sprintf("%s.value = buffer%s.getDouble(0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				} else if (param.ParamType == "pointer") {
					resultCommands = append(resultCommands, fmt.Sprintf("%s.value = buffer%s.getPointer(0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				}

			case "string":
				initCommands = append(initCommands, "Pointer bytesNeeded"+param.ParamName+" = new Memory(4);")

				initCallParameters = initCallParameters + fmt.Sprintf("0, bytesNeeded%s, null", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("int size%s = bytesNeeded%s.getInt(0);", param.ParamName, param.ParamName))
				postInitCommands = append(postInitCommands, fmt.Sprintf("Pointer buffer%s = new Memory(size%s);", param.ParamName, param.ParamName))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("size%s, bytesNeeded%s, buffer%s", param.ParamName, param.ParamName, param.ParamName)

				resultCommands = append(resultCommands, fmt.Sprintf("%s.value = new String(buffer%s.getByteArray(0, size%s - 1), StandardCharsets.UTF_8);", 
					MakeFirstLowerCase(param.ParamName), param.ParamName, param.ParamName))

				doInitCall = true

			case "enum":
				defineCommands = append(defineCommands, "Result"+param.ParamName+": Integer;")
				initCommands = append(initCommands, "Result"+param.ParamName+" := 0;")

				callFunctionParameters = callFunctionParameters + "Result" + param.ParamName
				initCallParameters = initCallParameters + "Result" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("A%s := convertConstTo%s(Result%s);", param.ParamName, param.ParamClass, param.ParamName))

			case "bool":
				defineCommands = append(defineCommands, "Result"+param.ParamName+": Byte;")
				initCommands = append(initCommands, "Result"+param.ParamName+" := 0;")

				callFunctionParameters = callFunctionParameters + "Result" + param.ParamName
				initCallParameters = initCallParameters + "Result" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("A%s := Result%s != 0;", param.ParamName, param.ParamName))

			case "struct":
				callFunctionParameters = callFunctionParameters + "@A" + param.ParamName
				initCallParameters = initCallParameters + "@A" + param.ParamName

			case "basicarray", "structarray":

				defineCommands = append(defineCommands, "countNeeded"+param.ParamName+": QWord;")
				defineCommands = append(defineCommands, "countWritten"+param.ParamName+": QWord;")
				initCommands = append(initCommands, "countNeeded"+param.ParamName+":= 0;")
				initCommands = append(initCommands, "countWritten"+param.ParamName+":= 0;")

				initCallParameters = initCallParameters + fmt.Sprintf("0, countNeeded%s, nil", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("SetLength(A%s, countNeeded%s);", param.ParamName, param.ParamName))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("countNeeded%s, countWritten%s, @A%s[0]", param.ParamName, param.ParamName, param.ParamName)

				doInitCall = true

			case "class", "optionalclass":
				theNameSpace, theParamClass, _ := decomposeParamClassName(param.ParamClass)
				theWrapperInstance := wrapperInstanceName
				if len(theNameSpace) > 0 {
					theWrapperInstance = theWrapperInstance + "." + theNameSpace + "Wrapper"
				} else {
					theNameSpace = NameSpace
				}

				defineCommands = append(defineCommands, "H"+param.ParamName+": "+PlainParamTypeName+";")
				initCommands = append(initCommands, fmt.Sprintf("A%s := nil;", param.ParamName))
				initCommands = append(initCommands, "H"+param.ParamName+" := nil;")
				callFunctionParameters = callFunctionParameters + "H" + param.ParamName
				initCallParameters = initCallParameters + "nil"

				resultCommands = append(resultCommands, fmt.Sprintf("if Assigned(H%s) then", param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("  A%s := T%s%s.Create(%s, H%s);", param.ParamName, theNameSpace, theParamClass, theWrapperInstance, param.ParamName))

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)
			}

		case "return":


			switch param.ParamType {
			case "bool":
				initCommands = append(initCommands, "Pointer buffer" + param.ParamName + " = new Memory(1);")

				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("boolean %s = buffer%s.getByte(0) != 0;", MakeFirstLowerCase(param.ParamName), param.ParamName))
				returnStmt = MakeFirstLowerCase(param.ParamName) + ";"

			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double", "pointer":
				if (param.ParamType == "uint8" || param.ParamType == "int8") {
					initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(1);")
				} else if (param.ParamType == "uint16" || param.ParamType == "int16") {
					initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(2);")
				} else if (param.ParamType == "uint32" || param.ParamType == "int32" || param.ParamType == "single") {
					initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(4);")
				} else if (param.ParamType == "uint64" || param.ParamType == "int64" || param.ParamType == "double" || param.ParamType == "pointer") {
					initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(8);")
				}
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName
				if (param.ParamType == "uint8") {
					returnStmt = fmt.Sprintf("buffer%s.getChar(0);", param.ParamName)
				} else if (param.ParamType == "int8") {
					returnStmt = fmt.Sprintf("buffer%s.getByte(0);", param.ParamName)
				} else if (param.ParamType == "uint16" || param.ParamType == "int16") {
					returnStmt = fmt.Sprintf("buffer%s.getShort(0);", param.ParamName)
				} else if (param.ParamType == "uint32" || param.ParamType == "int32") {
					returnStmt = fmt.Sprintf("buffer%s.getInt(0);", param.ParamName)
				} else if (param.ParamType == "uint64" || param.ParamType == "int64") {
					returnStmt = fmt.Sprintf("buffer%s.getLong(0);", param.ParamName)
				} else if (param.ParamType == "single") {
					returnStmt = fmt.Sprintf("buffer%s.getFloat(0);", param.ParamName)
				} else if (param.ParamType == "double") {
					returnStmt = fmt.Sprintf("buffer%s.getDouble(0);", param.ParamName)
				} else if (param.ParamType == "pointer") {
					returnStmt = fmt.Sprintf("buffer%s.getPointer(0);", param.ParamName)
				}

			case "string":
				initCommands = append(initCommands, "Pointer bytesNeeded"+param.ParamName+" = new Memory(4);")

				initCallParameters = initCallParameters + fmt.Sprintf("0, bytesNeeded%s, null", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("int size%s = bytesNeeded%s.getInt(0);", param.ParamName, param.ParamName))
				postInitCommands = append(postInitCommands, fmt.Sprintf("Pointer buffer%s = new Memory(size%s);", param.ParamName, param.ParamName))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("size%s, bytesNeeded%s, buffer%s", param.ParamName, param.ParamName, param.ParamName)

				resultCommands = append(resultCommands, fmt.Sprintf("String %s = new String(buffer%s.getByteArray(0, size%s - 1), StandardCharsets.UTF_8);", 
					MakeFirstLowerCase(param.ParamName), param.ParamName, param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("return %s;", MakeFirstLowerCase(param.ParamName)))

				doInitCall = true

			case "enum":
				defineCommands = append(defineCommands, "Result"+param.ParamName+": Integer;")
				initCommands = append(initCommands, "Result"+param.ParamName+" := 0;")

				callFunctionParameters = callFunctionParameters + "Result" + param.ParamName
				initCallParameters = initCallParameters + "Result" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("  Result := convertConstTo%s(Result%s);", param.ParamClass, param.ParamName))

			case "struct":
				initCommands = append(initCommands, param.ParamClass + " " + MakeFirstLowerCase(param.ParamName) + " = new " + param.ParamClass + "();")
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName)
				resultCommands = append(resultCommands, fmt.Sprintf("return %s;", MakeFirstLowerCase(param.ParamName)))

			case "basicarray", "structarray":
				defineCommands = append(defineCommands, "countNeeded"+param.ParamName+": QWord;")
				defineCommands = append(defineCommands, "countWritten"+param.ParamName+": QWord;")
				initCommands = append(initCommands, "countNeeded"+param.ParamName+":= 0;")
				initCommands = append(initCommands, "countWritten"+param.ParamName+":= 0;")

				initCallParameters = initCallParameters + fmt.Sprintf("0, countNeeded%s, nil", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("SetLength(Result, countNeeded%s);", param.ParamName))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("countNeeded%s, countWritten%s, @Result[0]", param.ParamName, param.ParamName)

				doInitCall = true

			case "class", "optionalclass":
				theNameSpace, theParamClass, _ := decomposeParamClassName(param.ParamClass)
				theWrapperInstance := wrapperInstanceName
				if len(theNameSpace) > 0 {
					theWrapperInstance = theWrapperInstance + "." + theNameSpace + "Wrapper"
				} else {
					theNameSpace = NameSpace
				}
				initCommands = append(initCommands, "Pointer buffer" + param.ParamName + " = new Memory(8);")
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("Pointer value%s = buffer%s.getPointer(0);", param.ParamName, param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("%s %s = null;", theParamClass, MakeFirstLowerCase(param.ParamName)))
				resultCommands = append(resultCommands, fmt.Sprintf("if (value%s == Pointer.NULL) {", param.ParamName))
				if param.ParamType == "class" {
					resultCommands = append(resultCommands, fmt.Sprintf(indent + "throw new %sException(%s_ERROR_NORESULTAVAILABLE, \"%s was a null pointer\");", 
						NameSpace, strings.ToUpper(NameSpace), param.ParamName))
				} else {
					resultCommands = append(resultCommands, fmt.Sprintf("%s = null;", theParamClass, MakeFirstLowerCase(param.ParamName)))
				}
				resultCommands = append(resultCommands, fmt.Sprintf("} else {"))
				resultCommands = append(resultCommands, indent + fmt.Sprintf("%s = new %s(%s, value%s);", MakeFirstLowerCase(param.ParamName), theParamClass, theWrapperInstance, param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("}"))
				returnStmt = MakeFirstLowerCase(param.ParamName) + ";"

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)
			}

		}
	}

	if isGlobal {
		w.Writeln(indent + "public %s %s(%s) throws %sException {", returnType, MakeFirstLowerCase(method.MethodName), parameters, NameSpace)
	} else {
		w.Writeln(indent + "public %s %s(%s) throws %sWrapper.%sException {", returnType, MakeFirstLowerCase(method.MethodName), parameters, NameSpace, NameSpace)
	}

	if len(defineCommands) > 0 {
		w.Writelns(indent + indent, defineCommands)
	}

	w.Writelns(indent + indent, initCommands)

	if doInitCall {
		w.Writeln("    %scheckError(%s, %s%s(%s));", wrapperCallPrefix, errorInstanceHandle, wrapperCallPrefix, callFunctionName, initCallParameters)
	}

	w.Writelns("    ", postInitCommands)

	w.Writeln("    %scheckError(%s, %s%s(%s));", wrapperCallPrefix, errorInstanceHandle, wrapperCallPrefix, callFunctionName, callFunctionParameters)

	w.Writelns(indent + indent, resultCommands)

	if len(returnStmt) > 0 {
		w.Writeln(indent + indent + "return " + returnStmt)
	}

	w.Writeln(indent + "}")
	w.Writeln("")

	return nil
}

func buildJavaStruct(component ComponentDefinition, w LanguageWriter, indent string, structinfo ComponentDefinitionStruct) error {

	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.Structure;")
	w.Writeln("")
	w.Writeln("import java.util.Arrays;")
	w.Writeln("import java.util.List;")
	w.Writeln("")
	w.Writeln("public class %s extends Structure implements Structure.ByReference {", structinfo.Name)
	w.Writeln("")
	fields := ""

	for j := 0; j < len(structinfo.Members); j++ {
		element := structinfo.Members[j]
		arrayprefix := ""
		if element.Rows > 0 {
			if element.Columns > 0 {
				arrayprefix = fmt.Sprintf("[%d][%d]", element.Columns-1, element.Rows-1)
			} else {
				arrayprefix = fmt.Sprintf("[%d]", element.Rows-1)
			}
		}
		if fields != "" {
			fields = fields + ", "
		}
		fields = fields + "\"" + element.Name + "\""

		switch element.Type {
		case "uint8":
			w.Writeln(indent + "public byte%s %s;", arrayprefix, element.Name)
		case "uint16":
			w.Writeln(indent + "public short%s %s;", arrayprefix, element.Name)
		case "uint32":
			w.Writeln(indent + "public int%s %s;", arrayprefix, element.Name)
		case "uint64":
			w.Writeln(indent + "public long%s %s;", arrayprefix, element.Name)
		case "int8":
			w.Writeln(indent + "public char%s %s;", arrayprefix, element.Name)
		case "int16":
			w.Writeln(indent + "public short%s %s;", arrayprefix, element.Name)
		case "int32":
			w.Writeln(indent + "public int%s %s;", arrayprefix, element.Name)
		case "int64":
			w.Writeln(indent + "public long%s %s;", arrayprefix, element.Name)
		case "bool":
			w.Writeln(indent + "public boolean%s %s;", arrayprefix, element.Name)
		case "single":
			w.Writeln(indent + "public float%s %s;", arrayprefix, element.Name)
		case "double":
			w.Writeln(indent + "public double%s %s;", arrayprefix, element.Name)
		case "pointer":
			w.Writeln(indent + "public Pointer%s %s;", arrayprefix, element.Name)
		case "string":
			return fmt.Errorf("it is not possible for struct s%s%s to contain a string value", component.NameSpace, structinfo.Name)
		case "class", "optionalclass":
			return fmt.Errorf("it is not possible for struct s%s%s to contain a handle value", component.NameSpace, structinfo.Name)
		case "enum":
			w.Writeln(indent + "int%s m%s;", arrayprefix, element.Name)
		}
	}
	w.Writeln("")
	w.Writeln(indent + "public static final String[] FIELDS = new String[] { " + fields + " };")
	w.Writeln("")
	w.Writeln(indent + "@Override")
	w.Writeln(indent + "protected List<String> getFieldOrder() {")
	w.Writeln(indent + indent + "return Arrays.asList(FIELDS);")
	w.Writeln(indent + "};")
	w.Writeln("")

	w.Writeln("}")
	w.Writeln("")
	return nil
}

func buildJavaWrapper(component ComponentDefinition, w LanguageWriter, indent string) error {

	NameSpace := component.NameSpace
	JavaWrapperName := NameSpace + "Wrapper";

	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.Library;")
	w.Writeln("import com.sun.jna.Memory;")
	w.Writeln("import com.sun.jna.Native;")
	w.Writeln("import com.sun.jna.Pointer;")
	w.Writeln("")
	w.Writeln("import java.nio.charset.StandardCharsets;")

	w.Writeln("")
	w.Writeln("public class " + JavaWrapperName + " {")
	w.Writeln("")
	w.Writeln(indent + "// Error Constants for %s", NameSpace)
	w.Writeln(indent + "public static final int %s_SUCCESS = 0;", strings.ToUpper(NameSpace))
	for i := 0; i < len(component.Errors.Errors); i++ {
		errorcode := component.Errors.Errors[i]
		w.Writeln(indent + "public static final int %s_ERROR_%s = %d;", strings.ToUpper(NameSpace), errorcode.Name, errorcode.Code)
	}
	w.Writeln("")
	w.Writeln(indent + "public static class %sException extends Exception {", NameSpace)
	w.Writeln("")
	w.Writeln(indent + indent + "protected int mErrorCode;")
	w.Writeln("")
	w.Writeln(indent + indent + "public SimpleLibException(int errorCode, String message){")
	w.Writeln(indent + indent + indent + "super(message);")
	w.Writeln(indent + indent + "}")
	w.Writeln(indent + "}")
	w.Writeln("")


	primitives := []string{ "byte", "char", "short", "int", "long", "boolean", "float", "double", "String" }
	for i := 0; i < len(primitives); i++ {
		w.Writeln(indent + "public static class %sOut { public %s value; }", MakeFirstUpperCase(primitives[i]), primitives[i])
		w.Writeln("")
	}

	w.Writeln(indent + "public interface I" + NameSpace + " extends Library {")
	spacing := indent + indent
	for j:=0; j<len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		parameter, err := generateParametersForMethod(method, "", NameSpace, true)
		if err != nil {
			return err
		}
		w.Writeln("")
		w.Writeln(spacing + "/**")
		w.Writeln(spacing + "* %s", method.MethodDescription)
		w.Writeln(spacing + "* @return error code or 0 (success)")
		w.Writeln(spacing + "*/")
		w.Writeln(spacing + "int %s_%s (%s);", strings.ToLower(NameSpace), strings.ToLower(method.MethodName), parameter)
	}
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		for j:=0; j<len(class.Methods); j++ {
			method := class.Methods[j]
			parameter, err := generateParametersForMethod(method, class.ClassName, NameSpace, false)
			if err != nil {
				return err
			}
			w.Writeln("")
			w.Writeln(spacing + "/**")
			w.Writeln(spacing + "* %s", method.MethodDescription)
			w.Writeln(spacing + "* @return error code or 0 (success)")
			w.Writeln(spacing + "*/")
			w.Writeln(spacing + "int %s_%s_%s (%s);", strings.ToLower(NameSpace), strings.ToLower(class.ClassName), strings.ToLower(method.MethodName), parameter)
		}
	}
	w.Writeln(indent + "}")
	w.Writeln("")
	w.Writeln(indent + "protected I" + NameSpace + " mInterface;")
	w.Writeln("")
	w.Writeln(indent + "public " + JavaWrapperName + "(String libraryPath) {")
	w.Writeln(indent + indent + "mInterface = Native.load(libraryPath, I" + NameSpace + ".class);")
	w.Writeln(indent + "}")
	w.Writeln("")
	w.Writeln(indent + "public I" + NameSpace + " getInterface() {")
	w.Writeln(indent + indent + "return mInterface;")
	w.Writeln(indent + "}")
	w.Writeln("")
	w.Writeln(indent + "protected void checkError(%s instance, int errorCode) throws %sException {", component.Global.BaseClassName, NameSpace)
	w.Writeln(indent + indent + "if (instance != null && instance.mWrapper != this) {")
	w.Writeln(indent + indent + indent + "throw new %sException(%s_ERROR_INVALIDCAST, \"invalid wrapper call\");", NameSpace, strings.ToUpper(NameSpace))
	w.Writeln(indent + indent + "}")
	w.Writeln(indent + indent + "if (errorCode != %s_SUCCESS) {", strings.ToUpper(NameSpace))
	w.Writeln(indent + indent + indent + "StringOut errorMessage = new " + NameSpace + "Wrapper.StringOut();")
	w.Writeln(indent + indent + indent + "if (instance != null) {")
	w.Writeln(indent + indent + indent + indent + "%s(instance, errorMessage);", MakeFirstLowerCase(component.Global.ErrorMethod))
	w.Writeln(indent + indent + indent + "}")
	w.Writeln(indent + indent + indent + "throw new %sException(errorCode, errorMessage.value);", NameSpace)
	w.Writeln(indent + indent + "}")
	w.Writeln(indent + "}")
	w.Writeln("")

	for j := 0; j < len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]

		err := writeJavaClassMethodImplementation(method, w, NameSpace, "", indent, true)
		if err != nil {
			return err
		}
	}

	w.Writeln("}")
	w.Writeln("")

	return nil
}

func generateParametersForMethod(method ComponentDefinitionMethod, ClassName string, NameSpace string, isGlobal bool) (string, error) {
	parameters := "";
	if isGlobal {

	} else {

		parameters = fmt.Sprintf("Pointer %s", MakeFirstLowerCase(ClassName))
	}

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]

		javaParams, err := generatePlainJavaParameter(param, ClassName, method.MethodName, NameSpace)
		if err != nil {
			return "", err
		}

		for _, javaParam := range javaParams {
			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + javaParam.ParamConvention + javaParam.ParamType + " " + javaParam.ParamName
		}

	}
	return parameters, nil;
}

func generatePlainJavaParameter(param ComponentDefinitionParam, className string, methodName string, NameSpace string) ([]javaParameter, error) {
	cParams := make([]javaParameter, 1)
	cParamTypeName, err := getJavaParameterType(param.ParamType, NameSpace, param.ParamClass, param.ParamPass, true)
	if err != nil {
		return nil, err
	}

	switch param.ParamPass {
	case "in":
		switch param.ParamType {
		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "bool", "single", "double", "pointer", "string", "enum":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "struct":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "basicarray", "structarray":
			cParams = make([]javaParameter, 2)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = cParamTypeName
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[1].ParamComment = fmt.Sprintf("* @param[in] %s - %s buffer of %s", cParams[1].ParamName, param.ParamClass, param.ParamDescription)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

		case "functiontype":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "class", "optionalclass":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		default:
			return nil, fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, className, methodName, param.ParamName)
		}

	case "out", "return":

		switch param.ParamType {

		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "bool", "single", "double", "pointer", "enum":
			cParams[0].ParamType = "Pointer"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "struct":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "basicarray":
			cParams = make([]javaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededSize"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written elements, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "structarray":
			cParams = make([]javaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededSize"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written elements, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "string":
			cParams = make([]javaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "BufferSize"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - size of the buffer (including trailing 0)", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededBuffer"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written bytes, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s, may be NULL", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "class", "optionalclass":
			cParams[0].ParamType = "Pointer"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		default:
			return nil, fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, className, methodName, param.ParamName)
		}


	default:
		return nil, fmt.Errorf("invalid method parameter passing \"%s\" for %s.%s(%s)", param.ParamPass, className, methodName, param.ParamName)
	}

	return cParams, nil
}

func getJavaParameterType(ParamTypeName string, NameSpace string, ParamClass string, ParamPass string, isPlain bool) (string, error) {
	JavaParamTypeName := ""
	switch ParamTypeName {
	case "uint8":
		if ParamPass == "out" {
			JavaParamTypeName = "CharOut"
		} else {
			JavaParamTypeName = "char"
		}

	case "uint16", "int16":
		if ParamPass == "out" {
			JavaParamTypeName = "ShortOut"
		} else {
			JavaParamTypeName = "short"
		}

	case "uint32", "int32":
		if ParamPass == "out" {
			JavaParamTypeName = "IntOut"
		} else {
			JavaParamTypeName = "int"
		}

	case "uint64", "int64":
		if ParamPass == "out" {
			JavaParamTypeName = "LongOut"
		} else {
			JavaParamTypeName = "long"
		}

	case "int8":
		if ParamPass == "out" {
			JavaParamTypeName = "ByteOut"
		} else {
			JavaParamTypeName = "byte"
		}

	case "bool":
		if ParamPass == "out" {
			JavaParamTypeName = "BooleanOut"
		} else {
			JavaParamTypeName = "boolean"
		}

	case "single":
		if ParamPass == "out" {
			JavaParamTypeName = "FloatOut"
		} else {
			JavaParamTypeName = "float"
		}

	case "double":
		if ParamPass == "out" {
			JavaParamTypeName = "DoubleOut"
		} else {
			JavaParamTypeName = "double"
		}

	case "pointer":
		JavaParamTypeName = "Pointer"

	case "string":
		if isPlain {
			JavaParamTypeName = "Pointer"
		} else {
			if ParamPass == "out" {
				JavaParamTypeName = "StringOut"
			} else {
				JavaParamTypeName = "String"
			}
		}

	case "enum":
		if isPlain {
			JavaParamTypeName = fmt.Sprintf("Pointer")
		} else {
			JavaParamTypeName = fmt.Sprintf("int")
		}

	case "functiontype":
		if isPlain {
			JavaParamTypeName = fmt.Sprintf("P%s_%s", NameSpace, ParamClass)
		} else {
			JavaParamTypeName = fmt.Sprintf("P%s_%s", NameSpace, ParamClass)
		}

	case "struct":
		JavaParamTypeName = ParamClass

	case "basicarray":
		basicTypeName, err := getJavaParameterType(ParamClass, NameSpace, "", "in", isPlain)
		if err != nil {
			return "", err
		}

		if isPlain {
			JavaParamTypeName = fmt.Sprintf("Pointer")
		} else {
			JavaParamTypeName = fmt.Sprintf("%s[]", basicTypeName)
		}

	case "structarray":
		if isPlain {
			JavaParamTypeName = fmt.Sprintf("Pointer")
		} else {
			JavaParamTypeName = fmt.Sprintf("%s[]", ParamClass)
		}

	case "class", "optionalclass":
		if isPlain {
			JavaParamTypeName = fmt.Sprintf("Pointer")
		} else {
			SubNameSpace, SubClassName, _ := decomposeParamClassName(ParamClass)
			if len(SubNameSpace) > 0 {
				JavaParamTypeName = fmt.Sprintf("%s", SubClassName)
			} else {
				JavaParamTypeName = fmt.Sprintf("%s", ParamClass)
			}
		}

	default:
		return "", fmt.Errorf("invalid parameter type \"%s\" for Java parameter", ParamTypeName)
	}

	return JavaParamTypeName, nil
}

func MakeFirstLowerCase(s string) string {
    
    if len(s) < 2 {
        return strings.ToLower(s)
    }
    
    bts := []byte(s)
    
    lc := bytes.ToLower([]byte{bts[0]})
    rest := bts[1:]
    
    return string(bytes.Join([][]byte{lc, rest}, nil))   
}

func MakeFirstUpperCase(s string) string {
    
    if len(s) < 2 {
        return strings.ToLower(s)
    }
    
    bts := []byte(s)
    
    lc := bytes.ToUpper([]byte{bts[0]})
    rest := bts[1:]
    
    return string(bytes.Join([][]byte{lc, rest}, nil))   
}
