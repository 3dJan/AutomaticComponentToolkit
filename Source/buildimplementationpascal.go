/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildimplementationpascal .go
// functions to generate Pascal interface classes, implementation stubs and wrapper code that maps to
// the Pascal header.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"log"
	"path"
	"math/rand"
	"strings"
)


// BuildImplementationPascal builds Pascal interface classes, implementation stubs and wrapper code that maps to the Pascal header
func BuildImplementationPascal(component ComponentDefinition, outputFolder string, stubOutputFolder string, projectOutputFolder string, implementation ComponentDefinitionImplementation) error {
	//doJournal := len (component.Global.JournalMethod) > 0;
	forceRecreation := false

	namespace := component.NameSpace;
	libraryname := component.LibraryName;
	baseName := component.BaseName;

	indentString := getIndentationString(implementation.Indentation)
	stubIdentifier := ""
	if len(implementation.StubIdentifier) > 0 {
		stubIdentifier = "_" + strings.ToLower(implementation.StubIdentifier)
	}

	IntfWrapperTypesName := path.Join(outputFolder, baseName+"_types.pas");
	log.Printf("Creating \"%s\"", IntfWrapperTypesName)
	typesWrapperfile, err := CreateLanguageFile(IntfWrapperTypesName, indentString)
	if err != nil {
		return err
	}
	typesWrapperfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal type definition file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", libraryname),
		true)
		
		
	buildPascalTypeDefinition (component, typesWrapperfile, namespace, baseName);

	
	IntfWrapperExceptionName := path.Join(outputFolder, baseName+"_exception.pas");
	log.Printf("Creating \"%s\"", IntfWrapperExceptionName)
	exceptionWrapperfile, err := CreateLanguageFile(IntfWrapperExceptionName, indentString)
	if err != nil {
		return err
	}
	exceptionWrapperfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal exception class definition file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", libraryname),
		true)
		
		
	buildPascalExceptionDefinition (component, exceptionWrapperfile, namespace, baseName);
	

	IntfWrapperInterfaceName := path.Join(outputFolder, baseName+"_interfaces.pas");
	log.Printf("Creating \"%s\"", IntfWrapperInterfaceName)
	interfaceWrapperfile, err := CreateLanguageFile(IntfWrapperInterfaceName, indentString)
	if err != nil {
		return err
	}
	interfaceWrapperfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal interface definition file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", libraryname),
		true)
		
		
	buildPascalInterfaceDefinition (component, interfaceWrapperfile, namespace, baseName);
	
	
	IntfWrapperExportName := path.Join(outputFolder, baseName+"_exports.pas");
	log.Printf("Creating \"%s\"", IntfWrapperExportName)
	exportWrapperfile, err := CreateLanguageFile(IntfWrapperExportName, indentString)
	if err != nil {
		return err
	}
	exportWrapperfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal export implementation file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", libraryname),
		true)
		
	buildPascalExportsDefinition (component, exportWrapperfile, namespace, baseName);

	IntfWrapperStubName := path.Join(stubOutputFolder, baseName + stubIdentifier + ".pas")
	log.Printf("Creating \"%s\"", IntfWrapperStubName)
	templatefile, err := CreateLanguageFile (IntfWrapperStubName, indentString)
	if err != nil {
		return err
	}
	templatefile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal implementation file in order to allow easy\ndevelopment of %s. It needs to be generated only once.", libraryname),
		true)
	
	
	IntfWrapperLPIName := path.Join(projectOutputFolder, baseName+".lpi");
	log.Printf("Creating \"%s\"", IntfWrapperLPIName)
	lpifile, err := CreateLanguageFile (IntfWrapperLPIName, indentString)
	if err != nil {
		return err
	}

	err = buildLPIImplementation (component, lpifile, namespace, baseName);
	if err != nil {
		return err
	}

	
	IntfWrapperLPRName := path.Join(outputFolder, baseName+".lpr");
	log.Printf("Creating \"%s\"", IntfWrapperLPRName)
	lprfile, err := CreateLanguageFile (IntfWrapperLPRName, indentString)
	if err != nil {
		return err
	}
	lprfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal project file in order to allow easy\ndevelopment of %s.", libraryname),
		true);
		
	err = buildLPRImplementation (component, lprfile, namespace, baseName);
	if err != nil {
		return err
	}
	
	err = buildPascalStub(component, namespace, implementation.ClassIdentifier, baseName, stubOutputFolder, indentString, stubIdentifier, forceRecreation)
	if err != nil {
		return err
	}
	

	return nil
}

func buildPascalTypeDefinition(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("unit %s_types;", BaseName);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");

	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	
	writePascalBaseTypeDefinitions (componentdefinition, w, NameSpace, BaseName);
	
	w.Writeln ("implementation");
	w.Writeln ("");

	w.Writeln ("end.");
	
	return nil;

}



func buildPascalExceptionDefinition(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("unit %s_exception;", BaseName);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");

	w.Writeln ("  %s_types,", BaseName);
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	w.Writeln ("type");
	w.Writeln ("  E%sException = class (Exception)", NameSpace);
	w.Writeln ("  private");
	w.Writeln ("    FErrorCode: T%sResult;", NameSpace);
	w.Writeln ("    FCustomMessage: String;");	
	w.Writeln ("  public");
	w.Writeln ("    property ErrorCode: T%sResult read FErrorCode;", NameSpace);
	w.Writeln ("    property CustomMessage: String read FCustomMessage;");	
	w.Writeln ("    constructor Create (AErrorCode: T%sResult);", NameSpace);
	w.Writeln ("    constructor CreateCustomMessage (AErrorCode: T%sResult; AMessage: String);", NameSpace);	
	w.Writeln ("  end;");
	w.Writeln ("")
	w.Writeln ("")
		
	w.Writeln ("implementation");
	w.Writeln ("");
	w.Writeln ("  constructor E%sException.Create (AErrorCode: T%sResult);", NameSpace, NameSpace);
	w.Writeln ("  var");	
	w.Writeln ("    ADescription: String;");	
	w.Writeln ("  begin");	
	w.Writeln ("    FErrorCode := AErrorCode;");	
	w.Writeln ("    case FErrorCode of");	
	
	for _, error := range componentdefinition.Errors.Errors {
		w.Writeln ("      %s_ERROR_%s: ADescription := '%s';", strings.ToUpper (NameSpace), error.Name, error.Description);		
	}
	
	w.Writeln ("      else");		
	w.Writeln ("        ADescription := 'unknown';");	
	w.Writeln ("    end;");	
	w.Writeln ("")
	w.Writeln ("    inherited Create (Format ('%s Error - %%s (#%%d)', [ ADescription, AErrorCode ]));", componentdefinition.LibraryName);	
	w.Writeln ("  end;");	
	w.Writeln ("")
	w.Writeln ("  constructor E%sException.CreateCustomMessage (AErrorCode: T%sResult; AMessage: String);", NameSpace, NameSpace);	
	w.Writeln ("  begin");	
	w.Writeln ("    FCustomMessage := AMessage;");	
	w.Writeln ("    FErrorCode := AErrorCode;");	
	w.Writeln ("    inherited Create (Format ('%%s (%%d)', [FCustomMessage, AErrorCode]));");	
	w.Writeln ("  end;");	
	w.Writeln ("")

	w.Writeln ("end.");
	
	return nil;

}


func createRandomUUID () (string, error) {

	u := make([]byte, 16)
	
	_, err := rand.Read(u)
	if err != nil {
		return "", err
	}

	u[8] = (u[8] | 0x80) & 0xBF // what does this do?
	u[6] = (u[6] | 0x40) & 0x4F // what does this do?

	uuid := fmt.Sprintf("%X-%X-%X-%X-%X", u[0:4], u[4:6], u[6:8], u[8:10], u[10:]);
	
	return uuid, nil;
	
}

func buildPascalInterfaceDefinition(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("{$INTERFACES CORBA}");
	
	w.Writeln ("unit %s_interfaces;", BaseName);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");

	w.Writeln ("  %s_types,", BaseName);
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
		
	w.Writeln ("")
	w.Writeln ("(*************************************************************************************************************************")
	w.Writeln (" Interface definition for BaseClass")
	w.Writeln ("**************************************************************************************************************************)")
	w.Writeln ("");
	w.Writeln ("type");
	w.Writeln ("  I%sBaseClass = interface", NameSpace);	
	
	uuid, err := createRandomUUID ();
	if err != nil {
		return err
	}	
	w.Writeln ("    ['{%s}']", uuid);
		
	w.Writeln ("  end;");	
	w.Writeln ("")

	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		w.Writeln ("")
		w.Writeln ("(*************************************************************************************************************************")
		w.Writeln (" Interface definition for %s", class.ClassName)
		w.Writeln ("**************************************************************************************************************************)")
		w.Writeln ("");
		
		parentClassName := class.ParentClass
		if parentClassName == "" {
			parentClassName = "BaseClass"
		}
		

		w.Writeln ("  I%s%s = interface (I%s%s)", NameSpace, class.ClassName, NameSpace, parentClassName);	
		uuid, err := createRandomUUID ();
		if err != nil {
			return err
		}	
		w.Writeln ("    ['{%s}']", uuid);
		w.Writeln ("");
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			err := writePascalClassMethodDefinition(method, w, NameSpace, class.ClassName, false, "    ", true)
			if err != nil {
				return err;
			}
		}
		
		w.Writeln ("  end;");	
		w.Writeln ("")

	}
	
	w.Writeln ("implementation");
	w.Writeln ("");

	w.Writeln ("end.");
	
	return nil;

}


func writePascalExportDefinition (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool, spacing string, doComment bool) (error) {

    PascalExportName := GetCExportName (NameSpace, ClassName, method, isGlobal);

	parameters := "";
	if (isGlobal) {
	} else {
		parameters = fmt.Sprintf ("p%s: T%sHandle", ClassName, NameSpace);
	}

	if (doComment) {
		w.Writeln ( spacing + "(**");
		w.Writeln ( spacing + "* %s", method.MethodDescription);
		w.Writeln ( spacing + "*");
		if (!isGlobal) {
			w.Writeln ( spacing + "* @param[in] p%s - %s instance.", ClassName, ClassName);
		}
	}
	

	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		
		pascalParams, err := generatePlainPascalParameter(param, ClassName, method.MethodName, NameSpace);
		if (err != nil) {
			return err;
		}

		for _, pascalParam := range pascalParams {
		
			if (doComment) {
				w.Writeln (spacing + pascalParam.ParamComment);
			}
			
			if (parameters != "") {
				parameters = parameters + "; ";
			}
			parameters = parameters + pascalParam.ParamName + ": " + pascalParam.ParamTypeNoConvention;
		}

	}

	if (doComment) {
		w.Writeln (spacing + "* @return error code or 0 (success)");
		w.Writeln (spacing + "*)");
	}
	
	w.Writeln (spacing + "function %s (%s): T%sResult; cdecl;", PascalExportName, parameters, NameSpace);
	
	return nil;
}


func writePascalClassExportImplementation (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, spacing string, isGlobal bool) (error) {

/*var
  ANumberObject: TObject;
  AInterface: ILibNumbersNumber;
  AReturnValue: Double;
begin
  try
    if not Assigned (pNumber) then
      raise ELibNumbersException.Create (LIBNUMBERS_ERROR_INVALIDPARAM);
    if not Assigned (pValue) then
      raise ELibNumbersException.Create (LIBNUMBERS_ERROR_INVALIDPARAM);

    ANumberObject := TObject (pNumber);
    if Supports (ANumberObject, ILibNumbersNumber) then begin
      AInterface := ANumberObject as ILibNumbersNumber;
      AReturnValue := AInterface.Value ();

      PValue^ := AReturnValue;
    end;

    Result := LIBNUMBERS_SUCCESS;

  except
    On E: ELibNumbersException do begin
      Result := E.getErrorCode ();
    end;
    On E: Exception do begin
      Result := LIBNUMBERS_ERROR_GENERICEXCEPTION;
    end;
  end;
end; */


	variableDefinitions := make([]string, 0);
	parameterChecks := make([]string, 0);

	
	if (!isGlobal) {
		// Define variables
		variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  A%sObject: TObject;", ClassName));
		variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  A%sInterface: I%s%s;", ClassName, NameSpace, ClassName));	
	
		parameterChecks = append (parameterChecks, fmt.Sprintf ("    if not Assigned (p%s) then", ClassName));
		parameterChecks = append (parameterChecks, fmt.Sprintf ("      raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper (NameSpace)));
	}
	
	
	if (len (variableDefinitions) > 0) {
		w.Writeln (spacing + "var");
		w.Writelns (spacing, variableDefinitions);
	}		
	w.Writeln (spacing + "begin");
	w.Writeln (spacing + "  try");
	w.Writelns (spacing, parameterChecks);
	
	w.Writeln (spacing + "");
	if (!isGlobal) {
		w.Writeln (spacing + "    A%sObject := TObject (p%s);", ClassName, ClassName);
		w.Writeln (spacing + "    if Supports (A%sObject, I%s%s) then begin", ClassName, NameSpace, ClassName);
		w.Writeln (spacing + "      A%sInterface := A%sObject as I%s%s;", ClassName, ClassName, NameSpace, ClassName);
	}
	
	
	if (!isGlobal) {
		w.Writeln (spacing + "    end else");
		w.Writeln (spacing + "      raise E%sException.Create (%s_ERROR_INVALIDCAST);", NameSpace, strings.ToUpper (NameSpace));          
	}
	
	w.Writeln (spacing + "");
	w.Writeln (spacing + "    Result := %s_SUCCESS;", strings.ToUpper (NameSpace));
	w.Writeln (spacing + "  except");
    w.Writeln (spacing + "    On E: E%sException do begin", NameSpace);
    w.Writeln (spacing + "      Result := E.ErrorCode;");
    w.Writeln (spacing + "    end;");
    w.Writeln (spacing + "    On E: Exception do begin");
    w.Writeln (spacing + "      Result := %s_ERROR_GENERICEXCEPTION;", strings.ToUpper (NameSpace));
    w.Writeln (spacing + "    end;");
	w.Writeln (spacing + "  end;");
	w.Writeln (spacing + "end;");
	w.Writeln (spacing + "");
	
	return nil;
}



func buildPascalExportsDefinition(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	global := componentdefinition.Global;

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("unit %s_exports;", BaseName);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");
	w.Writeln ("  %s_types,", BaseName);
	w.Writeln ("  %s_interfaces,", BaseName);
	w.Writeln ("  %s_exception,", BaseName);
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		w.Writeln("(*************************************************************************************************************************")
		w.Writeln(" Class export definition of %s ", class.ClassName)
		w.Writeln("**************************************************************************************************************************)")
		w.Writeln("")
		
		for j := 0; j < len(class.Methods); j++ {
						
			method := class.Methods[j]
			
			err := writePascalExportDefinition (method, w, NameSpace, class.ClassName, false, "", true);
			if (err != nil) {
				return err;
			}
			
			w.Writeln ("");
		}

	}

	w.Writeln("(*************************************************************************************************************************")
	w.Writeln(" Global function export definition")
	w.Writeln("**************************************************************************************************************************)")
	w.Writeln ("");

	
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		
		err := writePascalExportDefinition (method, w, NameSpace, "Wrapper", true, "", true);
		if (err != nil) {
			return err;
		}
		
		w.Writeln ("");
	}

	
	w.Writeln ("implementation");
	w.Writeln ("");

	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		for j := 0; j < len(class.Methods); j++ {
						
			method := class.Methods[j]
			
			err := writePascalExportDefinition (method, w, NameSpace, class.ClassName, false, "", false);
			if (err != nil) {
				return err;
			}
			
			err = writePascalClassExportImplementation(method, w, NameSpace, class.ClassName, "", false);
			if (err != nil) {
				return err;
			}
		}

	}


	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		
		err := writePascalExportDefinition (method, w, NameSpace, "Wrapper", true, "", false);
		if (err != nil) {
			return err;
		}
		
		err = writePascalClassExportImplementation(method, w, NameSpace, "Wrapper", "", true);
		if (err != nil) {
			return err;
		}
		
	}
	
	w.Writeln ("");
	w.Writeln ("end.");
	w.Writeln ("");
	
	return nil;

}



func buildLPRImplementation(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	global := componentdefinition.Global;

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("library %s;", BaseName);
	w.Writeln ("");
	w.Writeln ("uses");
	w.Writeln ("{$IFDEF UNIX}");
	w.Writeln ("  cthreads,");
	w.Writeln ("{$ENDIF UNIX}");
	w.Writeln ("  syncobjs,");
	w.Writeln ("  %s_types,", BaseName);
	w.Writeln ("  %s_exports,", BaseName);
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	w.Writeln ("exports");
	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		for j := 0; j < len(class.Methods); j++ {
				
			commaString := ",";
			if ((j == (len(class.Methods) - 1)) && (len(global.Methods) == 0)) {
				commaString = ";";
			}
		
			method := class.Methods[j]
			w.Writeln ("  %s%s", GetCExportName (NameSpace, class.ClassName, method, false), commaString);
		}

	}


	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		commaString := ",";
		if (j == (len(global.Methods) - 1)) {
			commaString = ";";
		}
		
		w.Writeln ("  %s%s", GetCExportName (NameSpace, "Wrapper", method, true), commaString);
	}
	
	w.Writeln ("");
	w.Writeln ("begin");
	w.Writeln ("");
	w.Writeln ("end.");
	
	return nil;
       
}




func buildLPIImplementation(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
	w.Writeln ("<CONFIG>");
	w.Writeln ("  <ProjectOptions>");
	w.Writeln ("    <Version Value=\"%d\"/>", 10);
	
	
	w.Writeln ("    <PathDelim Value=\"\\\"/>");
	w.Writeln ("    <General>");
	w.Writeln ("      <Flags>");
	w.Writeln ("        <MainUnitHasCreateFormStatements Value=\"False\" />");
	w.Writeln ("        <MainUnitHasTitleStatement Value=\"False\" />");
	w.Writeln ("        <MainUnitHasScaledStatement Value=\"False\" />");
	w.Writeln ("      </Flags>");
	w.Writeln ("      <SessionStorage Value=\"InProjectDir\" />");
	w.Writeln ("      <MainUnit Value=\"%d\"/>", 0);
	w.Writeln ("      <Title Value=\"%s\" />", NameSpace);
	w.Writeln ("      <UseAppBundle Value=\"False\" />");
	w.Writeln ("      <ResourceType Value=\"res\" />");
	w.Writeln ("    </General>");
	w.Writeln ("    <BuildModes Count=\"%d\">", 2);
	w.Writeln ("      <Item1 Name=\"Release\" Default=\"True\"/>");
	w.Writeln ("      <Item2 Name=\"Debug\">");
	w.Writeln ("        <CompilerOptions>");
	w.Writeln ("          <Version Value=\"11\" />");
	w.Writeln ("          <PathDelim Value=\"\\\"/>");
	w.Writeln ("          <Target>");
	w.Writeln ("            <Filename Value=\"bin\\$(TargetCPU)-$(TargetOS)\\Release\\project%s\"/>", BaseName);
	w.Writeln ("          </Target>");
	w.Writeln ("          <SearchPaths>");
	w.Writeln ("            <IncludeFiles Value=\"$(ProjOutDir)\"/>");
	w.Writeln ("            <UnitOutputDirectory Value=\"lib\\$(TargetCPU)-$(TargetOS)\"/>");
	w.Writeln ("          </SearchPaths>");
	w.Writeln ("          <Parsing>");
	w.Writeln ("            <SyntaxOptions>");
	w.Writeln ("              <IncludeAssertionCode Value=\"True\"/>");
	w.Writeln ("            </SyntaxOptions>");
	w.Writeln ("          </Parsing>");
	w.Writeln ("          <CodeGeneration>");
	w.Writeln ("            <RelocatableUnit Value=\"True\" />");
	w.Writeln ("          </CodeGeneration>");
	w.Writeln ("          <Linking>");
	w.Writeln ("            <Debugging>");
	w.Writeln ("              <UseExternalDbgSyms Value=\"True\"/>");
	w.Writeln ("            </Debugging>");
	w.Writeln ("            <Options>");
	w.Writeln ("              <ExecutableType Value=\"Library\"/>");
	w.Writeln ("            </Options>");
	w.Writeln ("          </Linking>");
	w.Writeln ("        </CompilerOptions>");
	w.Writeln ("      </Item2>");
	w.Writeln ("    </BuildModes>");
	w.Writeln ("    <PublishOptions>");
	w.Writeln ("      <Version Value=\"%d\"/>", 2);
	w.Writeln ("    </PublishOptions>");
	w.Writeln ("    <RunParams>");
	w.Writeln ("      <local>");
	w.Writeln ("        <FormatVersion Value=\"1\"/>");
	w.Writeln ("      </local>");
	w.Writeln ("    </RunParams>");
	w.Writeln ("    <Units Count=\"%d\">", 1);
	w.Writeln ("      <Unit0>");
	w.Writeln ("        <Filename Value=\"Interfaces\\%s.lpr\"/>", BaseName);
	w.Writeln ("        <IsPartOfProject Value=\"True\"/>");	
	w.Writeln ("      </Unit0>");
	w.Writeln ("    </Units>");
	w.Writeln ("  </ProjectOptions>");
	w.Writeln ("  <CompilerOptions>");
	w.Writeln ("    <Version Value=\"%d\"/>", 11);
	w.Writeln ("    <PathDelim Value=\"\\\"/>");
	w.Writeln ("    <Target>");
	w.Writeln ("      <Filename Value=\"bin\\$(TargetCPU)-$(TargetOS)\\Release\\%s\"/>", BaseName);
	w.Writeln ("    </Target>");
	w.Writeln ("    <SearchPaths>");
	w.Writeln ("      <IncludeFiles Value=\"$(ProjOutDir)\"/>");
	w.Writeln ("      <UnitOutputDirectory Value=\"lib\\$(TargetCPU)-$(TargetOS)\"/>");
	w.Writeln ("    </SearchPaths>");
	w.Writeln ("    <Parsing>");
	w.Writeln ("      <SyntaxOptions>");
	w.Writeln ("        <IncludeAssertionCode Value=\"True\"/>");
	w.Writeln ("      </SyntaxOptions>");
	w.Writeln ("    </Parsing>");
	w.Writeln ("    <CodeGeneration>");
	w.Writeln ("      <RelocatableUnit Value=\"True\"/>");
	w.Writeln ("    </CodeGeneration>");
	w.Writeln ("    <Linking>");
	w.Writeln ("      <Debugging>");
	w.Writeln ("        <StripSymbols Value=\"True\"/>");
	w.Writeln ("        <UseExternalDbgSyms Value=\"True\"/>");
	w.Writeln ("      </Debugging>");
	w.Writeln ("      <Options>");
	w.Writeln ("        <ExecutableType Value=\"Library\"/>");
	w.Writeln ("      </Options>");
	w.Writeln ("    </Linking>");
	w.Writeln ("  </CompilerOptions>");
	w.Writeln ("  <Debugging>");
	w.Writeln ("    <Exceptions Count=\"%d\">", 3);
	w.Writeln ("      <Item1>");
	w.Writeln ("        <Name Value=\"EAbort\"/>");
	w.Writeln ("      </Item1>");
	w.Writeln ("      <Item2>");
	w.Writeln ("        <Name Value=\"ECodetoolError\"/>");
 	w.Writeln ("      </Item2>");
	w.Writeln ("      <Item3>");
	w.Writeln ("        <Name Value=\"EFOpenError\"/>");
	w.Writeln ("      </Item3>");
	w.Writeln ("    </Exceptions>");     
	w.Writeln ("  </Debugging>");
	w.Writeln ("</CONFIG>");    	
	w.Writeln ("");

	return nil;
	
}


func writePascalClassMethodDummyStub (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, outClassName string, isGlobal bool, spacing string) (error) {

	parameters, returnType, err := getPascalClassParameters (method, NameSpace, ClassName, isGlobal, true);
	if (err != nil) {
		return err;
	}

	if (returnType == "") {
		w.Writeln ( spacing + "procedure %s.%s(%s);", outClassName, method.MethodName, parameters);
	} else {
		w.Writeln ( spacing + "function %s.%s(%s): %s;", outClassName, method.MethodName, parameters, returnType);
	}
	
	w.Writeln ( spacing + "begin");
	w.Writeln ( spacing + "  raise E%sException (%s_ERROR_NOTIMPLEMENTED)", NameSpace, strings.ToUpper (NameSpace));
	w.Writeln ( spacing + "end;");
	w.Writeln ( spacing + "");
	
	
	return nil;
}




func buildPascalStub(component ComponentDefinition, NameSpace string, ClassIdentifier string, BaseName string, outputFolder string, indentString string, stubIdentifier string, forceRecreation bool) error {

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]

		parentClassName := class.ParentClass
		if parentClassName == "" {
			parentClassName = "BaseClass"
		}
		
		outClassName := "T" + ClassIdentifier + NameSpace + class.ClassName
		outparentClassName := "T" + ClassIdentifier + NameSpace + parentClassName

		StubFileName := path.Join(outputFolder, BaseName + stubIdentifier + "_" +strings.ToLower(class.ClassName)+".pas");
		if !forceRecreation && ( FileExists(StubFileName) ) {
			log.Printf("Omitting recreation of Stub implementation for \"%s\"", outClassName)
			continue;
		}

		log.Printf("Creating \"%s\"", StubFileName)
		w, err := CreateLanguageFile(StubFileName, indentString)
		if err != nil {
			return err
		}
		w.WritePascalLicenseHeader(component,
			fmt.Sprintf("This is the class declaration of %s", outClassName),
			false)
		

		w.Writeln ("{$MODE DELPHI}");
		w.Writeln ("unit %s%s_%s;", BaseName, stubIdentifier, strings.ToLower(class.ClassName));
		w.Writeln ("");
		w.Writeln ("interface");
		w.Writeln ("");
		w.Writeln ("uses");
		w.Writeln ("  %s_types,", BaseName);
		w.Writeln ("  %s_interfaces,", BaseName);
		w.Writeln ("  %s_exception,", BaseName);
		
		if (class.ParentClass != "") {
			w.Writeln ("  %s%s_%s,", BaseName, stubIdentifier, strings.ToLower(class.ClassName));
		}
		
		w.Writeln ("  Classes,");
		w.Writeln ("  sysutils;");
		w.Writeln ("");
			

		w.Writeln ("type");
		w.Writeln ("  %s = class (%s, I%s%s)", outClassName, outparentClassName, NameSpace, class.ClassName);
		w.Writeln ("    private");
		w.Writeln ("");
		w.Writeln ("    protected");
		w.Writeln ("");
		w.Writeln ("    public");
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			err := writePascalClassMethodDefinition(method, w, NameSpace, class.ClassName, false, "      ", true)
			if err != nil {
				return err;
			}
		}
		
		w.Writeln ("  end;");	
		w.Writeln ("")

	
		w.Writeln ("implementation");
		w.Writeln ("");
		
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			err := writePascalClassMethodDummyStub(method, w, NameSpace, class.ClassName, outClassName, false, "      ")
			if err != nil {
				return err;
			}
		}
		

		w.Writeln ("end.");

	}

	return nil
}


